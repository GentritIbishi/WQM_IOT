{"ast":null,"code":"import { latLng, tileLayer, marker, icon } from 'leaflet';\nimport * as L from 'leaflet';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"../services/sensor-data.service\";\nimport * as i2 from \"../services/web-socket.service\";\nimport * as i3 from \"@angular/router\";\nimport * as i4 from \"@angular/common\";\nimport * as i5 from \"@angular/material/card\";\nimport * as i6 from \"@asymmetrik/ngx-leaflet\";\nimport * as i7 from \"ng2-charts\";\nfunction DashboardComponent_div_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r1 = i0.ÉµÉµgetCurrentView();\n    i0.ÉµÉµelementStart(0, \"div\")(1, \"div\", 9);\n    i0.ÉµÉµlistener(\"click\", function DashboardComponent_div_2_Template_div_click_1_listener() {\n      const alert_r2 = i0.ÉµÉµrestoreView(_r1).$implicit;\n      return i0.ÉµÉµresetView(alert_r2.onClick());\n    });\n    i0.ÉµÉµtext(2);\n    i0.ÉµÉµelementStart(3, \"button\", 10);\n    i0.ÉµÉµlistener(\"click\", function DashboardComponent_div_2_Template_button_click_3_listener() {\n      const i_r3 = i0.ÉµÉµrestoreView(_r1).index;\n      const ctx_r3 = i0.ÉµÉµnextContext();\n      return i0.ÉµÉµresetView(ctx_r3.closeAlert(i_r3));\n    });\n    i0.ÉµÉµelementStart(4, \"span\", 11);\n    i0.ÉµÉµtext(5, \"\\u00D7\");\n    i0.ÉµÉµelementEnd()()()();\n  }\n  if (rf & 2) {\n    const alert_r2 = ctx.$implicit;\n    i0.ÉµÉµadvance(2);\n    i0.ÉµÉµtextInterpolate1(\" \", alert_r2.message, \" \");\n  }\n}\nexport class DashboardComponent {\n  sensorDataService;\n  webSocketService;\n  router;\n  sensorData = [];\n  locations = [];\n  isWaterQualityGood = true;\n  totalSensors = 0;\n  activeSensors = 0;\n  totalLocations = 0; // Add a new variable to track total locations\n  mapCenter = latLng(0, 0);\n  mapZoom = 2;\n  mapOptions = {\n    layers: [tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {\n      maxZoom: 18,\n      attribution: 'Â© OpenStreetMap contributors'\n    })],\n    zoom: this.mapZoom,\n    center: this.mapCenter\n  };\n  mapMarkers = [];\n  leafletMap = null; // Store the Leaflet map instance\n  alerts = [];\n  // Doughnut chart data for water purity\n  doughnutChartType = 'doughnut'; // Define the chart type\n  doughnutChartData = {\n    labels: ['Drinkable', 'NOT Drinkable', 'Anomaly'],\n    // Initial labels for the chart\n    datasets: [{\n      data: [0, 0, 0],\n      // Placeholder for initial data\n      backgroundColor: ['#4caf50', '#f44336', '#ffa500'] // Colors for the chart segments\n    }]\n  };\n  constructor(sensorDataService, webSocketService, router) {\n    this.sensorDataService = sensorDataService;\n    this.webSocketService = webSocketService;\n    this.router = router;\n  }\n  ngOnInit() {\n    this.fetchSensorData();\n    this.listenForAnomalies(); // Listen for anomalies\n  }\n  onMapReady(map) {\n    this.leafletMap = map; // Save the Leaflet map instance when it is ready\n  }\n  fetchSensorData() {\n    this.sensorDataService.getLatestSensorData().subscribe({\n      next: data => {\n        this.sensorData = data;\n        this.processLocations();\n        this.updateMapMarkers();\n      },\n      error: err => {\n        console.error('Error fetching sensor data:', err);\n      }\n    });\n  }\n  processLocations() {\n    const groupedLocations = this.sensorData.reduce((acc, data) => {\n      const key = `${data.latitude},${data.longitude}`;\n      if (!acc[key]) {\n        acc[key] = [];\n      }\n      acc[key].push(data);\n      return acc;\n    }, {});\n    let drinkableCount = 0;\n    let notDrinkableCount = 0;\n    let anomalyCount = 0;\n    this.locations = Object.keys(groupedLocations).map(key => {\n      const locationData = groupedLocations[key];\n      const [latitude, longitude] = key.split(',').map(Number);\n      let qualityStatus;\n      let color;\n      // Calculate quality status\n      if (locationData.every(reading => reading.prediction === 0)) {\n        qualityStatus = 'NOT Drinkable';\n        color = 'red';\n        notDrinkableCount++;\n      } else if (locationData.every(reading => reading.prediction === 1)) {\n        qualityStatus = 'Drinkable';\n        color = 'green';\n        drinkableCount++;\n      } else if (locationData.every(reading => reading.prediction === 2)) {\n        qualityStatus = 'Anomaly';\n        color = 'orange';\n        anomalyCount++;\n      } else {\n        qualityStatus = 'Mixed';\n        color = 'gray';\n      }\n      // Calculate active and total sensors for each location\n      const totalLocationSensors = locationData.length * 4; // 4 types of sensors\n      const activeLocationSensors = locationData.filter(reading => reading.temperature && reading.ph && reading.flow && reading.turbidity).length * 4;\n      this.totalSensors += totalLocationSensors;\n      this.activeSensors += totalLocationSensors;\n      return {\n        latitude,\n        longitude,\n        qualityStatus,\n        color,\n        readings: locationData\n      };\n    });\n    this.isWaterQualityGood = this.locations.every(location => location.qualityStatus === 'Drinkable');\n    // Update total locations\n    this.totalLocations = this.locations.length;\n    // Update the chart data based on the count of Drinkable, NOT Drinkable, and Anomaly locations\n    this.updateDoughnutChartData(drinkableCount, notDrinkableCount, anomalyCount);\n  }\n  updateDoughnutChartData(drinkableCount, notDrinkableCount, anomalyCount) {\n    this.doughnutChartData.datasets[0].data = [drinkableCount, notDrinkableCount, anomalyCount];\n  }\n  updateMapMarkers() {\n    const bounds = new L.LatLngBounds([]); // Initialize an empty bounds object\n    this.mapMarkers = this.locations.map(location => {\n      const markerInstance = marker([location.latitude, location.longitude], {\n        icon: icon({\n          iconSize: [25, 41],\n          iconAnchor: [13, 41],\n          iconUrl: location.qualityStatus === 'Drinkable' ? 'assets/greenMarker24x24.png' : location.qualityStatus === 'NOT Drinkable' ? 'assets/redMarker24x24.png' : 'assets/orangeMarker24x24.png'\n        })\n      }).bindPopup(`<b>Location (${location.latitude.toFixed(2)}, ${location.longitude.toFixed(2)})</b><br>\n                    <b>Water Quality:</b> <span style=\"color: ${location.color}\">${location.qualityStatus}</span><br>\n                    <b>Temperature:</b> ${location.readings[0].temperature} Â°C<br>\n                    <b>pH:</b> ${location.readings[0].ph}<br>\n                    <b>Turbidity:</b> ${location.readings[0].turbidity}`);\n      // Extend the bounds to include this marker's position\n      bounds.extend([location.latitude, location.longitude]);\n      return markerInstance;\n    });\n    // If there are locations and the map instance is ready, zoom to fit the bounds\n    if (this.leafletMap && this.locations.length > 0) {\n      this.leafletMap.fitBounds(bounds); // Fit the map to the bounds of the markers\n    }\n  }\n  listenForAnomalies() {\n    this.webSocketService.messages$.subscribe(message => {\n      try {\n        const anomalyData = typeof message === 'string' ? JSON.parse(message) : message;\n        console.log('Anomaly data received:', anomalyData);\n        this.showAnomalyNotification(anomalyData); // Pass anomaly data to the notification function\n      } catch (error) {\n        console.error('Error parsing anomaly message:', error);\n      }\n    });\n  }\n  showAnomalyNotification(anomalyData) {\n    this.alerts.push({\n      type: 'warning',\n      message: `ðŸš¨ Anomaly Detected: ${anomalyData.length} new anomalies detected.`,\n      dismissible: true,\n      timeout: 10000,\n      onClick: () => {\n        // Navigate to the desired route when the alert is clicked\n        this.router.navigate(['/airiskalerts']);\n      }\n    });\n  }\n  closeAlert(index) {\n    this.alerts.splice(index, 1); // Remove the alert at the specified index\n  }\n  static Éµfac = function DashboardComponent_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || DashboardComponent)(i0.ÉµÉµdirectiveInject(i1.SensorDataService), i0.ÉµÉµdirectiveInject(i2.WebSocketService), i0.ÉµÉµdirectiveInject(i3.Router));\n  };\n  static Éµcmp = /*@__PURE__*/i0.ÉµÉµdefineComponent({\n    type: DashboardComponent,\n    selectors: [[\"app-dashboard\"]],\n    decls: 19,\n    vars: 9,\n    consts: [[4, \"ngFor\", \"ngForOf\"], [1, \"dashboard-wrapper\"], [1, \"left-column\"], [1, \"two\"], [1, \"dashboard-card\", \"centered-card\"], [1, \"chart-wrapper\"], [\"baseChart\", \"\", 3, \"data\", \"type\"], [1, \"right-column\"], [\"leaflet\", \"\", 3, \"leafletMapReady\", \"leafletOptions\", \"leafletZoom\", \"leafletCenter\", \"leafletLayers\"], [\"id\", \"cAlert\", \"role\", \"alert\", 1, \"alert\", \"alert-warning\", \"alert-dismissible\", \"fade\", \"show\", 3, \"click\"], [\"id\", \"closeButton\", \"type\", \"button\", \"aria-label\", \"Close\", 1, \"close\", 3, \"click\"], [\"aria-hidden\", \"true\"]],\n    template: function DashboardComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ÉµÉµelementStart(0, \"h1\");\n        i0.ÉµÉµtext(1, \"Dashboard Overview\");\n        i0.ÉµÉµelementEnd();\n        i0.ÉµÉµtemplate(2, DashboardComponent_div_2_Template, 6, 1, \"div\", 0);\n        i0.ÉµÉµelementStart(3, \"div\", 1)(4, \"div\", 2)(5, \"div\", 3)(6, \"mat-card\", 4)(7, \"mat-card-title\");\n        i0.ÉµÉµtext(8);\n        i0.ÉµÉµelementEnd()();\n        i0.ÉµÉµelementStart(9, \"mat-card\", 4)(10, \"mat-card-title\");\n        i0.ÉµÉµtext(11);\n        i0.ÉµÉµelementEnd()()();\n        i0.ÉµÉµelementStart(12, \"mat-card\", 4)(13, \"mat-card-title\");\n        i0.ÉµÉµtext(14, \"Water Purity\");\n        i0.ÉµÉµelementEnd();\n        i0.ÉµÉµelementStart(15, \"div\", 5);\n        i0.ÉµÉµelement(16, \"canvas\", 6);\n        i0.ÉµÉµelementEnd()()();\n        i0.ÉµÉµelementStart(17, \"div\", 7)(18, \"div\", 8);\n        i0.ÉµÉµlistener(\"leafletMapReady\", function DashboardComponent_Template_div_leafletMapReady_18_listener($event) {\n          return ctx.onMapReady($event);\n        });\n        i0.ÉµÉµelementEnd()()();\n      }\n      if (rf & 2) {\n        i0.ÉµÉµadvance(2);\n        i0.ÉµÉµproperty(\"ngForOf\", ctx.alerts);\n        i0.ÉµÉµadvance(6);\n        i0.ÉµÉµtextInterpolate1(\"Active Sensors: \", ctx.activeSensors, \"\");\n        i0.ÉµÉµadvance(3);\n        i0.ÉµÉµtextInterpolate1(\"Total Locations: \", ctx.totalLocations, \"\");\n        i0.ÉµÉµadvance(5);\n        i0.ÉµÉµproperty(\"data\", ctx.doughnutChartData)(\"type\", ctx.doughnutChartType);\n        i0.ÉµÉµadvance(2);\n        i0.ÉµÉµproperty(\"leafletOptions\", ctx.mapOptions)(\"leafletZoom\", ctx.mapZoom)(\"leafletCenter\", ctx.mapCenter)(\"leafletLayers\", ctx.mapMarkers);\n      }\n    },\n    dependencies: [i4.NgForOf, i5.MatCard, i5.MatCardTitle, i6.LeafletDirective, i6.LeafletLayersDirective, i7.BaseChartDirective],\n    styles: [\".dashboard-wrapper[_ngcontent-%COMP%] {\\n  display: flex;\\n  justify-content: space-between;\\n  width: 100%;\\n  padding: 20px;\\n  background-color: #f9f9f9; \\n\\n  border-radius: 10px;\\n  box-shadow: 0px 4px 15px rgba(0, 0, 0, 0.05);\\n}\\n\\n.left-column[_ngcontent-%COMP%] {\\n  display: flex;\\n  flex-direction: column;\\n  gap: 20px; \\n\\n  width: 35%;\\n}\\n\\n.right-column[_ngcontent-%COMP%] {\\n  width: 60%;\\n  height: 100%;\\n  position: relative;\\n  margin: 20px 0;\\n  background-color: #fff;\\n  border-radius: 10px;\\n  box-shadow: 0px 4px 15px rgba(0, 0, 0, 0.1); \\n\\n  padding: 20px;\\n}\\n\\n.right-column[_ngcontent-%COMP%]    > div[_ngcontent-%COMP%] {\\n  height: 400px;\\n  border-radius: 10px;\\n  overflow: hidden;\\n}\\n\\n.dashboard-card[_ngcontent-%COMP%] {\\n  width: 100%;\\n  padding: 20px;\\n  border-radius: 15px;\\n  box-shadow: 0px 4px 15px rgba(0, 0, 0, 0.1); \\n\\n  background-color: #ffffff;\\n  transition: transform 0.3s ease, box-shadow 0.3s ease; \\n\\n}\\n\\n.dashboard-card[_ngcontent-%COMP%]:hover {\\n  transform: translateY(-5px); \\n\\n  box-shadow: 0px 8px 20px rgba(0, 0, 0, 0.15); \\n\\n}\\n\\n.centered-card[_ngcontent-%COMP%] {\\n  text-align: center;\\n}\\n\\n.mat-card-title[_ngcontent-%COMP%] {\\n  font-size: 1.5em;\\n  color: #333;\\n  font-weight: 600;\\n  margin-bottom: 10px;\\n}\\n\\n.chart-wrapper[_ngcontent-%COMP%] {\\n  display: flex;\\n  justify-content: center;\\n  align-items: center;\\n  height: 300px;\\n}\\n\\n#cAlert[_ngcontent-%COMP%] {\\n  cursor: pointer;\\n  margin-bottom: 10px;\\n  border-radius: 5px;\\n  transition: background-color 0.3s ease;\\n}\\n\\n#cAlert[_ngcontent-%COMP%]:hover {\\n  background-color: #f1c40f; \\n\\n}\\n\\n.two[_ngcontent-%COMP%] {\\n  display: flex;\\n  justify-content: space-between;\\n  flex-wrap: wrap;\\n  gap: 20px;\\n}\\n\\n@media (max-width: 768px) {\\n  .dashboard-wrapper[_ngcontent-%COMP%] {\\n    flex-direction: column;\\n  }\\n  .right-column[_ngcontent-%COMP%] {\\n    width: 100%;\\n    height: 300px;\\n  }\\n  .left-column[_ngcontent-%COMP%] {\\n    width: 100%;\\n  }\\n  .dashboard-card[_ngcontent-%COMP%] {\\n    margin-bottom: 20px;\\n  }\\n}\\n\\n\\nh1[_ngcontent-%COMP%] {\\n  font-family: \\\"Roboto\\\", sans-serif;\\n  font-weight: 700;\\n  color: #2c3e50;\\n  margin-bottom: 40px;\\n}\\n\\np[_ngcontent-%COMP%], h2[_ngcontent-%COMP%] {\\n  font-family: \\\"Roboto\\\", sans-serif;\\n  color: #555;\\n}\\n\\n\\n\\nbutton#closeButton[_ngcontent-%COMP%] {\\n  background: none;\\n  border: none;\\n  font-size: 1.2em;\\n  color: #e74c3c;\\n  cursor: pointer;\\n}\\n\\nbutton#closeButton[_ngcontent-%COMP%]:hover {\\n  color: #c0392b;\\n}\\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8uL3NyYy9hcHAvZGFzaGJvYXJkL2Rhc2hib2FyZC5jb21wb25lbnQuc2NzcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtFQUNFLGFBQUE7RUFDQSw4QkFBQTtFQUNBLFdBQUE7RUFDQSxhQUFBO0VBQ0EseUJBQUEsRUFBQSxrQ0FBQTtFQUNBLG1CQUFBO0VBQ0EsNENBQUE7QUFDRjs7QUFFQTtFQUNFLGFBQUE7RUFDQSxzQkFBQTtFQUNBLFNBQUEsRUFBQSxpQ0FBQTtFQUNBLFVBQUE7QUFDRjs7QUFFQTtFQUNFLFVBQUE7RUFDQSxZQUFBO0VBQ0Esa0JBQUE7RUFDQSxjQUFBO0VBQ0Esc0JBQUE7RUFDQSxtQkFBQTtFQUNBLDJDQUFBLEVBQUEsNEJBQUE7RUFDQSxhQUFBO0FBQ0Y7O0FBRUE7RUFDRSxhQUFBO0VBQ0EsbUJBQUE7RUFDQSxnQkFBQTtBQUNGOztBQUVBO0VBQ0UsV0FBQTtFQUNBLGFBQUE7RUFDQSxtQkFBQTtFQUNBLDJDQUFBLEVBQUEsZ0RBQUE7RUFDQSx5QkFBQTtFQUNBLHFEQUFBLEVBQUEsK0JBQUE7QUFDRjs7QUFFQTtFQUNFLDJCQUFBLEVBQUEsZ0NBQUE7RUFDQSw0Q0FBQSxFQUFBLDJCQUFBO0FBQ0Y7O0FBRUE7RUFDRSxrQkFBQTtBQUNGOztBQUVBO0VBQ0UsZ0JBQUE7RUFDQSxXQUFBO0VBQ0EsZ0JBQUE7RUFDQSxtQkFBQTtBQUNGOztBQUVBO0VBQ0UsYUFBQTtFQUNBLHVCQUFBO0VBQ0EsbUJBQUE7RUFDQSxhQUFBO0FBQ0Y7O0FBRUE7RUFDRSxlQUFBO0VBQ0EsbUJBQUE7RUFDQSxrQkFBQTtFQUNBLHNDQUFBO0FBQ0Y7O0FBRUE7RUFDRSx5QkFBQSxFQUFBLHVCQUFBO0FBQ0Y7O0FBRUE7RUFDRSxhQUFBO0VBQ0EsOEJBQUE7RUFDQSxlQUFBO0VBQ0EsU0FBQTtBQUNGOztBQUVBO0VBQ0U7SUFDRSxzQkFBQTtFQUNGO0VBRUE7SUFDRSxXQUFBO0lBQ0EsYUFBQTtFQUFGO0VBR0E7SUFDRSxXQUFBO0VBREY7RUFJQTtJQUNFLG1CQUFBO0VBRkY7QUFDRjtBQUtBLDRCQUFBO0FBQ0E7RUFDRSxpQ0FBQTtFQUNBLGdCQUFBO0VBQ0EsY0FBQTtFQUNBLG1CQUFBO0FBSEY7O0FBTUE7RUFDRSxpQ0FBQTtFQUNBLFdBQUE7QUFIRjs7QUFNQSx3QkFBQTtBQUNBO0VBQ0UsZ0JBQUE7RUFDQSxZQUFBO0VBQ0EsZ0JBQUE7RUFDQSxjQUFBO0VBQ0EsZUFBQTtBQUhGOztBQU1BO0VBQ0UsY0FBQTtBQUhGIiwic291cmNlc0NvbnRlbnQiOlsiLmRhc2hib2FyZC13cmFwcGVyIHtcbiAgZGlzcGxheTogZmxleDtcbiAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuICB3aWR0aDogMTAwJTtcbiAgcGFkZGluZzogMjBweDtcbiAgYmFja2dyb3VuZC1jb2xvcjogI2Y5ZjlmOTsgLyogTGlnaHQgYmFja2dyb3VuZCBmb3IgY29udHJhc3QgKi9cbiAgYm9yZGVyLXJhZGl1czogMTBweDtcbiAgYm94LXNoYWRvdzogMHB4IDRweCAxNXB4IHJnYmEoMCwgMCwgMCwgMC4wNSk7XG59XG5cbi5sZWZ0LWNvbHVtbiB7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gIGdhcDogMjBweDsgLyogQWRkcyBzcGFjZSBiZXR3ZWVuIHRoZSBjYXJkcyAqL1xuICB3aWR0aDogMzUlO1xufVxuXG4ucmlnaHQtY29sdW1uIHtcbiAgd2lkdGg6IDYwJTtcbiAgaGVpZ2h0OiAxMDAlO1xuICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gIG1hcmdpbjogMjBweCAwO1xuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmO1xuICBib3JkZXItcmFkaXVzOiAxMHB4O1xuICBib3gtc2hhZG93OiAwcHggNHB4IDE1cHggcmdiYSgwLCAwLCAwLCAwLjEpOyAvKiBTdWJ0bGUgc2hhZG93IGZvciBkZXB0aCAqL1xuICBwYWRkaW5nOiAyMHB4O1xufVxuXG4ucmlnaHQtY29sdW1uID4gZGl2IHtcbiAgaGVpZ2h0OiA0MDBweDtcbiAgYm9yZGVyLXJhZGl1czogMTBweDtcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcbn1cblxuLmRhc2hib2FyZC1jYXJkIHtcbiAgd2lkdGg6IDEwMCU7XG4gIHBhZGRpbmc6IDIwcHg7XG4gIGJvcmRlci1yYWRpdXM6IDE1cHg7XG4gIGJveC1zaGFkb3c6IDBweCA0cHggMTVweCByZ2JhKDAsIDAsIDAsIDAuMSk7IC8qIFN0cm9uZ2VyIHNoYWRvdyBmb3IgYmV0dGVyIHZpc3VhbCBoaWVyYXJjaHkgKi9cbiAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZmZmZjtcbiAgdHJhbnNpdGlvbjogdHJhbnNmb3JtIDAuM3MgZWFzZSwgYm94LXNoYWRvdyAwLjNzIGVhc2U7IC8qIFNtb290aCB0cmFuc2l0aW9uIG9uIGhvdmVyICovXG59XG5cbi5kYXNoYm9hcmQtY2FyZDpob3ZlciB7XG4gIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgtNXB4KTsgLyogU2xpZ2h0IGxpZnQgZWZmZWN0IG9uIGhvdmVyICovXG4gIGJveC1zaGFkb3c6IDBweCA4cHggMjBweCByZ2JhKDAsIDAsIDAsIDAuMTUpOyAvKiBMYXJnZXIgc2hhZG93IG9uIGhvdmVyICovXG59XG5cbi5jZW50ZXJlZC1jYXJkIHtcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xufVxuXG4ubWF0LWNhcmQtdGl0bGUge1xuICBmb250LXNpemU6IDEuNWVtO1xuICBjb2xvcjogIzMzMztcbiAgZm9udC13ZWlnaHQ6IDYwMDtcbiAgbWFyZ2luLWJvdHRvbTogMTBweDtcbn1cblxuLmNoYXJ0LXdyYXBwZXIge1xuICBkaXNwbGF5OiBmbGV4O1xuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgaGVpZ2h0OiAzMDBweDtcbn1cblxuI2NBbGVydCB7XG4gIGN1cnNvcjogcG9pbnRlcjtcbiAgbWFyZ2luLWJvdHRvbTogMTBweDtcbiAgYm9yZGVyLXJhZGl1czogNXB4O1xuICB0cmFuc2l0aW9uOiBiYWNrZ3JvdW5kLWNvbG9yIDAuM3MgZWFzZTtcbn1cblxuI2NBbGVydDpob3ZlciB7XG4gIGJhY2tncm91bmQtY29sb3I6ICNmMWM0MGY7IC8qIEhpZ2hsaWdodCBvbiBob3ZlciAqL1xufVxuXG4udHdvIHtcbiAgZGlzcGxheTogZmxleDtcbiAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuICBmbGV4LXdyYXA6IHdyYXA7XG4gIGdhcDogMjBweDtcbn1cblxuQG1lZGlhIChtYXgtd2lkdGg6IDc2OHB4KSB7XG4gIC5kYXNoYm9hcmQtd3JhcHBlciB7XG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgfVxuXG4gIC5yaWdodC1jb2x1bW4ge1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIGhlaWdodDogMzAwcHg7XG4gIH1cblxuICAubGVmdC1jb2x1bW4ge1xuICAgIHdpZHRoOiAxMDAlO1xuICB9XG5cbiAgLmRhc2hib2FyZC1jYXJkIHtcbiAgICBtYXJnaW4tYm90dG9tOiAyMHB4O1xuICB9XG59XG5cbi8qIFR5cG9ncmFwaHkgaW1wcm92ZW1lbnRzICovXG5oMSB7XG4gIGZvbnQtZmFtaWx5OiAnUm9ib3RvJywgc2Fucy1zZXJpZjtcbiAgZm9udC13ZWlnaHQ6IDcwMDtcbiAgY29sb3I6ICMyYzNlNTA7XG4gIG1hcmdpbi1ib3R0b206IDQwcHg7XG59XG5cbnAsIGgyIHtcbiAgZm9udC1mYW1pbHk6ICdSb2JvdG8nLCBzYW5zLXNlcmlmO1xuICBjb2xvcjogIzU1NTtcbn1cblxuLyogQnV0dG9uIGltcHJvdmVtZW50cyAqL1xuYnV0dG9uI2Nsb3NlQnV0dG9uIHtcbiAgYmFja2dyb3VuZDogbm9uZTtcbiAgYm9yZGVyOiBub25lO1xuICBmb250LXNpemU6IDEuMmVtO1xuICBjb2xvcjogI2U3NGMzYztcbiAgY3Vyc29yOiBwb2ludGVyO1xufVxuXG5idXR0b24jY2xvc2VCdXR0b246aG92ZXIge1xuICBjb2xvcjogI2MwMzkyYjtcbn1cblxuIl0sInNvdXJjZVJvb3QiOiIifQ== */\"]\n  });\n}","map":{"version":3,"names":["latLng","tileLayer","marker","icon","L","i0","ÉµÉµelementStart","ÉµÉµlistener","DashboardComponent_div_2_Template_div_click_1_listener","alert_r2","ÉµÉµrestoreView","_r1","$implicit","ÉµÉµresetView","onClick","ÉµÉµtext","DashboardComponent_div_2_Template_button_click_3_listener","i_r3","index","ctx_r3","ÉµÉµnextContext","closeAlert","ÉµÉµelementEnd","ÉµÉµadvance","ÉµÉµtextInterpolate1","message","DashboardComponent","sensorDataService","webSocketService","router","sensorData","locations","isWaterQualityGood","totalSensors","activeSensors","totalLocations","mapCenter","mapZoom","mapOptions","layers","maxZoom","attribution","zoom","center","mapMarkers","leafletMap","alerts","doughnutChartType","doughnutChartData","labels","datasets","data","backgroundColor","constructor","ngOnInit","fetchSensorData","listenForAnomalies","onMapReady","map","getLatestSensorData","subscribe","next","processLocations","updateMapMarkers","error","err","console","groupedLocations","reduce","acc","key","latitude","longitude","push","drinkableCount","notDrinkableCount","anomalyCount","Object","keys","locationData","split","Number","qualityStatus","color","every","reading","prediction","totalLocationSensors","length","activeLocationSensors","filter","temperature","ph","flow","turbidity","readings","location","updateDoughnutChartData","bounds","LatLngBounds","markerInstance","iconSize","iconAnchor","iconUrl","bindPopup","toFixed","extend","fitBounds","messages$","anomalyData","JSON","parse","log","showAnomalyNotification","type","dismissible","timeout","navigate","splice","ÉµÉµdirectiveInject","i1","SensorDataService","i2","WebSocketService","i3","Router","selectors","decls","vars","consts","template","DashboardComponent_Template","rf","ctx","ÉµÉµtemplate","DashboardComponent_div_2_Template","ÉµÉµelement","DashboardComponent_Template_div_leafletMapReady_18_listener","$event","ÉµÉµproperty"],"sources":["/Users/gentritibishi/IdeaProjects/WQM_IOT/src/app/dashboard/dashboard.component.ts","/Users/gentritibishi/IdeaProjects/WQM_IOT/src/app/dashboard/dashboard.component.html"],"sourcesContent":["import { Component, OnInit } from '@angular/core';\nimport { latLng, tileLayer, marker, icon, Marker } from 'leaflet';\nimport { Router } from '@angular/router';\nimport { SensorData, SensorDataService } from '../services/sensor-data.service';\nimport { WebSocketService } from '../services/web-socket.service';\nimport { ChartType, ChartData } from 'chart.js';\nimport * as L from 'leaflet';\n\n@Component({\n  selector: 'app-dashboard',\n  templateUrl: './dashboard.component.html',\n  styleUrls: ['./dashboard.component.scss']\n})\nexport class DashboardComponent implements OnInit {\n  sensorData: SensorData[] = [];\n  locations: any[] = [];\n  isWaterQualityGood: boolean = true;\n  totalSensors: number = 0;\n  activeSensors: number = 0;\n  totalLocations: number = 0; // Add a new variable to track total locations\n  mapCenter = latLng(0, 0);\n  mapZoom = 2;\n  mapOptions = {\n    layers: [\n      tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {\n        maxZoom: 18,\n        attribution: 'Â© OpenStreetMap contributors'\n      })\n    ],\n    zoom: this.mapZoom,\n    center: this.mapCenter\n  };\n  mapMarkers: Marker[] = [];\n  leafletMap: L.Map | null = null; // Store the Leaflet map instance\n\n  alerts: any[] = [];\n\n  // Doughnut chart data for water purity\n  public doughnutChartType: ChartType = 'doughnut'; // Define the chart type\n  public doughnutChartData: ChartData<'doughnut'> = {\n    labels: ['Drinkable', 'NOT Drinkable', 'Anomaly'], // Initial labels for the chart\n    datasets: [\n      {\n        data: [0, 0, 0], // Placeholder for initial data\n        backgroundColor: ['#4caf50', '#f44336', '#ffa500'], // Colors for the chart segments\n      }\n    ]\n  };\n\n  constructor(\n    private sensorDataService: SensorDataService,\n    private webSocketService: WebSocketService,\n    private router: Router\n  ) {}\n\n  ngOnInit(): void {\n    this.fetchSensorData();\n    this.listenForAnomalies(); // Listen for anomalies\n  }\n\n  onMapReady(map: L.Map): void {\n    this.leafletMap = map; // Save the Leaflet map instance when it is ready\n  }\n\n  fetchSensorData(): void {\n    this.sensorDataService.getLatestSensorData().subscribe({\n      next: data => {\n        this.sensorData = data;\n        this.processLocations();\n        this.updateMapMarkers();\n      },\n      error: err => {\n        console.error('Error fetching sensor data:', err);\n      }\n    });\n  }\n\n  processLocations(): void {\n    const groupedLocations: Record<string, SensorData[]> = this.sensorData.reduce((acc: Record<string, SensorData[]>, data: SensorData) => {\n      const key = `${data.latitude},${data.longitude}`;\n      if (!acc[key]) {\n        acc[key] = [];\n      }\n      acc[key].push(data);\n      return acc;\n    }, {});\n\n    let drinkableCount = 0;\n    let notDrinkableCount = 0;\n    let anomalyCount = 0;\n\n    this.locations = Object.keys(groupedLocations).map(key => {\n      const locationData = groupedLocations[key];\n      const [latitude, longitude] = key.split(',').map(Number);\n\n      let qualityStatus: string;\n      let color: string;\n\n      // Calculate quality status\n      if (locationData.every(reading => reading.prediction === 0)) {\n        qualityStatus = 'NOT Drinkable';\n        color = 'red';\n        notDrinkableCount++;\n      } else if (locationData.every(reading => reading.prediction === 1)) {\n        qualityStatus = 'Drinkable';\n        color = 'green';\n        drinkableCount++;\n      } else if (locationData.every(reading => reading.prediction === 2)) {\n        qualityStatus = 'Anomaly';\n        color = 'orange';\n        anomalyCount++;\n      } else {\n        qualityStatus = 'Mixed';\n        color = 'gray';\n      }\n\n      // Calculate active and total sensors for each location\n      const totalLocationSensors = locationData.length * 4; // 4 types of sensors\n      const activeLocationSensors = locationData.filter(reading =>\n        reading.temperature && reading.ph && reading.flow && reading.turbidity\n      ).length * 4;\n\n      this.totalSensors += totalLocationSensors;\n      this.activeSensors += totalLocationSensors;\n\n      return {\n        latitude,\n        longitude,\n        qualityStatus,\n        color,\n        readings: locationData\n      };\n    });\n\n    this.isWaterQualityGood = this.locations.every(location => location.qualityStatus === 'Drinkable');\n\n    // Update total locations\n    this.totalLocations = this.locations.length;\n\n    // Update the chart data based on the count of Drinkable, NOT Drinkable, and Anomaly locations\n    this.updateDoughnutChartData(drinkableCount, notDrinkableCount, anomalyCount);\n  }\n\n  updateDoughnutChartData(drinkableCount: number, notDrinkableCount: number, anomalyCount: number): void {\n    this.doughnutChartData.datasets[0].data = [drinkableCount, notDrinkableCount, anomalyCount];\n  }\n\n  updateMapMarkers(): void {\n    const bounds = new L.LatLngBounds([]); // Initialize an empty bounds object\n\n    this.mapMarkers = this.locations.map(location => {\n      const markerInstance = marker([location.latitude, location.longitude], {\n        icon: icon({\n          iconSize: [25, 41],\n          iconAnchor: [13, 41],\n          iconUrl: location.qualityStatus === 'Drinkable'\n            ? 'assets/greenMarker24x24.png'\n            : location.qualityStatus === 'NOT Drinkable'\n              ? 'assets/redMarker24x24.png'\n              : 'assets/orangeMarker24x24.png'\n        })\n      }).bindPopup(`<b>Location (${location.latitude.toFixed(2)}, ${location.longitude.toFixed(2)})</b><br>\n                    <b>Water Quality:</b> <span style=\"color: ${location.color}\">${location.qualityStatus}</span><br>\n                    <b>Temperature:</b> ${location.readings[0].temperature} Â°C<br>\n                    <b>pH:</b> ${location.readings[0].ph}<br>\n                    <b>Turbidity:</b> ${location.readings[0].turbidity}`);\n\n      // Extend the bounds to include this marker's position\n      bounds.extend([location.latitude, location.longitude]);\n\n      return markerInstance;\n    });\n\n    // If there are locations and the map instance is ready, zoom to fit the bounds\n    if (this.leafletMap && this.locations.length > 0) {\n      this.leafletMap.fitBounds(bounds); // Fit the map to the bounds of the markers\n    }\n  }\n\n  listenForAnomalies(): void {\n    this.webSocketService.messages$.subscribe((message) => {\n      try {\n        const anomalyData = typeof message === 'string' ? JSON.parse(message) : message;\n        console.log('Anomaly data received:', anomalyData);\n        this.showAnomalyNotification(anomalyData); // Pass anomaly data to the notification function\n      } catch (error) {\n        console.error('Error parsing anomaly message:', error);\n      }\n    });\n  }\n\n  showAnomalyNotification(anomalyData: any): void {\n    this.alerts.push({\n      type: 'warning',\n      message: `ðŸš¨ Anomaly Detected: ${anomalyData.length} new anomalies detected.`,\n      dismissible: true,\n      timeout: 10000,\n      onClick: () => {\n        // Navigate to the desired route when the alert is clicked\n        this.router.navigate(['/airiskalerts']);\n      }\n    });\n  }\n\n  closeAlert(index: number): void {\n    this.alerts.splice(index, 1); // Remove the alert at the specified index\n  }\n}\n","<h1>Dashboard Overview</h1>\n\n<!-- Alerts Section -->\n<div *ngFor=\"let alert of alerts; let i = index\">\n  <div id=\"cAlert\" class=\"alert alert-warning alert-dismissible fade show\" role=\"alert\" (click)=\"alert.onClick()\">\n    {{ alert.message }}\n    <button id=\"closeButton\" type=\"button\" class=\"close\" aria-label=\"Close\" (click)=\"closeAlert(i)\">\n      <span aria-hidden=\"true\">&times;</span>\n    </button>\n  </div>\n</div>\n\n<div class=\"dashboard-wrapper\">\n  <div class=\"left-column\">\n   <div class=\"two\">\n     <!-- Total Sensors Card -->\n     <mat-card class=\"dashboard-card centered-card\">\n       <mat-card-title>Active Sensors: {{activeSensors}}</mat-card-title>\n     </mat-card>\n     <!-- Total Sensors Card -->\n     <mat-card class=\"dashboard-card centered-card\">\n       <mat-card-title>Total Locations: {{totalLocations}}</mat-card-title>\n     </mat-card>\n   </div>\n\n    <!-- Water Purity Card -->\n    <mat-card class=\"dashboard-card centered-card\">\n      <mat-card-title>Water Purity</mat-card-title>\n      <div class=\"chart-wrapper\">\n        <canvas baseChart\n                [data]=\"doughnutChartData\"\n                [type]=\"doughnutChartType\">\n        </canvas>\n      </div>\n    </mat-card>\n  </div>\n\n  <!-- Map with Sensor Locations -->\n  <div class=\"right-column\">\n    <div leaflet\n         [leafletOptions]=\"mapOptions\"\n         [leafletZoom]=\"mapZoom\"\n         [leafletCenter]=\"mapCenter\"\n         [leafletLayers]=\"mapMarkers\"\n         (leafletMapReady)=\"onMapReady($event)\">\n    </div>\n  </div>\n</div>\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}