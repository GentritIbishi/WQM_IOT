{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { EventEmitter, Directive, Input, Output, HostListener, NgModule } from '@angular/core';\nimport { latLng, map, control, tileLayer } from 'leaflet';\nclass LeafletUtil {\n  static mapToArray(map) {\n    const toReturn = [];\n    for (const k in map) {\n      if (map.hasOwnProperty(k)) {\n        toReturn.push(map[k]);\n      }\n    }\n    return toReturn;\n  }\n  static handleEvent(zone, eventEmitter, event) {\n    // Don't want to emit if there are no observers\n    if (0 < eventEmitter.observers.length) {\n      zone.run(() => {\n        eventEmitter.emit(event);\n      });\n    }\n  }\n}\nclass LeafletDirective {\n  constructor(element, zone) {\n    this.element = element;\n    this.zone = zone;\n    this.DEFAULT_ZOOM = 1;\n    this.DEFAULT_CENTER = latLng(38.907192, -77.036871);\n    this.DEFAULT_FPZ_OPTIONS = {};\n    this.fitBoundsOptions = this.DEFAULT_FPZ_OPTIONS;\n    this.panOptions = this.DEFAULT_FPZ_OPTIONS;\n    this.zoomOptions = this.DEFAULT_FPZ_OPTIONS;\n    this.zoomPanOptions = this.DEFAULT_FPZ_OPTIONS;\n    // Default configuration\n    this.options = {};\n    // Configure callback function for the map\n    this.mapReady = new EventEmitter();\n    this.zoomChange = new EventEmitter();\n    this.centerChange = new EventEmitter();\n    // Mouse Map Events\n    this.onClick = new EventEmitter();\n    this.onDoubleClick = new EventEmitter();\n    this.onMouseDown = new EventEmitter();\n    this.onMouseUp = new EventEmitter();\n    this.onMouseMove = new EventEmitter();\n    this.onMouseOver = new EventEmitter();\n    this.onMouseOut = new EventEmitter();\n    // Map Move Events\n    this.onMapMove = new EventEmitter();\n    this.onMapMoveStart = new EventEmitter();\n    this.onMapMoveEnd = new EventEmitter();\n    // Map Zoom Events\n    this.onMapZoom = new EventEmitter();\n    this.onMapZoomStart = new EventEmitter();\n    this.onMapZoomEnd = new EventEmitter();\n    // Nothing here\n  }\n  ngOnInit() {\n    // Create the map outside of angular so the various map events don't trigger change detection\n    this.zone.runOutsideAngular(() => {\n      // Create the map with some reasonable defaults\n      this.map = map(this.element.nativeElement, this.options);\n      this.addMapEventListeners();\n    });\n    // Only setView if there is a center/zoom\n    if (null != this.center && null != this.zoom) {\n      this.setView(this.center, this.zoom);\n    }\n    // Set up all the initial settings\n    if (null != this.fitBounds) {\n      this.setFitBounds(this.fitBounds);\n    }\n    if (null != this.maxBounds) {\n      this.setMaxBounds(this.maxBounds);\n    }\n    if (null != this.minZoom) {\n      this.setMinZoom(this.minZoom);\n    }\n    if (null != this.maxZoom) {\n      this.setMaxZoom(this.maxZoom);\n    }\n    this.doResize();\n    // Fire map ready event\n    this.mapReady.emit(this.map);\n  }\n  ngOnChanges(changes) {\n    /*\n     * The following code is to address an issue with our (basic) implementation of\n     * zooming and panning. From our testing, it seems that a pan operation followed\n     * by a zoom operation in the same thread will interfere with eachother. The zoom\n     * operation interrupts/cancels the pan, resulting in a final center point that is\n     * inaccurate. The solution seems to be to either separate them with a timeout or\n      * to collapse them into a setView call.\n     */\n    // Zooming and Panning\n    if (changes['zoom'] && changes['center'] && null != this.zoom && null != this.center) {\n      this.setView(changes['center'].currentValue, changes['zoom'].currentValue);\n    }\n    // Set the zoom level\n    else if (changes['zoom']) {\n      this.setZoom(changes['zoom'].currentValue);\n    }\n    // Set the map center\n    else if (changes['center']) {\n      this.setCenter(changes['center'].currentValue);\n    }\n    // Other options\n    if (changes['fitBounds']) {\n      this.setFitBounds(changes['fitBounds'].currentValue);\n    }\n    if (changes['maxBounds']) {\n      this.setMaxBounds(changes['maxBounds'].currentValue);\n    }\n    if (changes['minZoom']) {\n      this.setMinZoom(changes['minZoom'].currentValue);\n    }\n    if (changes['maxZoom']) {\n      this.setMaxZoom(changes['maxZoom'].currentValue);\n    }\n  }\n  ngOnDestroy() {\n    // If this directive is destroyed, the map is too\n    if (null != this.map) {\n      this.map.remove();\n    }\n  }\n  getMap() {\n    return this.map;\n  }\n  onResize() {\n    this.delayResize();\n  }\n  addMapEventListeners() {\n    const registerEventHandler = (eventName, handler) => {\n      this.map.on(eventName, handler);\n    };\n    // Add all the pass-through mouse event handlers\n    registerEventHandler('click', e => LeafletUtil.handleEvent(this.zone, this.onClick, e));\n    registerEventHandler('dblclick', e => LeafletUtil.handleEvent(this.zone, this.onDoubleClick, e));\n    registerEventHandler('mousedown', e => LeafletUtil.handleEvent(this.zone, this.onMouseDown, e));\n    registerEventHandler('mouseup', e => LeafletUtil.handleEvent(this.zone, this.onMouseUp, e));\n    registerEventHandler('mouseover', e => LeafletUtil.handleEvent(this.zone, this.onMouseOver, e));\n    registerEventHandler('mouseout', e => LeafletUtil.handleEvent(this.zone, this.onMouseOut, e));\n    registerEventHandler('mousemove', e => LeafletUtil.handleEvent(this.zone, this.onMouseMove, e));\n    registerEventHandler('zoomstart', e => LeafletUtil.handleEvent(this.zone, this.onMapZoomStart, e));\n    registerEventHandler('zoom', e => LeafletUtil.handleEvent(this.zone, this.onMapZoom, e));\n    registerEventHandler('zoomend', e => LeafletUtil.handleEvent(this.zone, this.onMapZoomEnd, e));\n    registerEventHandler('movestart', e => LeafletUtil.handleEvent(this.zone, this.onMapMoveStart, e));\n    registerEventHandler('move', e => LeafletUtil.handleEvent(this.zone, this.onMapMove, e));\n    registerEventHandler('moveend', e => LeafletUtil.handleEvent(this.zone, this.onMapMoveEnd, e));\n    // Update any things for which we provide output bindings\n    const outputUpdateHandler = () => {\n      const zoom = this.map.getZoom();\n      if (zoom !== this.zoom) {\n        this.zoom = zoom;\n        LeafletUtil.handleEvent(this.zone, this.zoomChange, zoom);\n      }\n      const center = this.map.getCenter();\n      if (null != center || null != this.center) {\n        if ((null == center || null == this.center) && center !== this.center || center.lat !== this.center.lat || center.lng !== this.center.lng) {\n          this.center = center;\n          LeafletUtil.handleEvent(this.zone, this.centerChange, center);\n        }\n      }\n    };\n    registerEventHandler('moveend', outputUpdateHandler);\n    registerEventHandler('zoomend', outputUpdateHandler);\n  }\n  /**\n   * Resize the map to fit it's parent container\n   */\n  doResize() {\n    // Run this outside of angular so the map events stay outside of angular\n    this.zone.runOutsideAngular(() => {\n      // Invalidate the map size to trigger it to update itself\n      if (null != this.map) {\n        this.map.invalidateSize({});\n      }\n    });\n  }\n  /**\n   * Manage a delayed resize of the component\n   */\n  delayResize() {\n    if (null != this.resizeTimer) {\n      clearTimeout(this.resizeTimer);\n    }\n    this.resizeTimer = setTimeout(this.doResize.bind(this), 200);\n  }\n  /**\n   * Set the view (center/zoom) all at once\n   * @param center The new center\n   * @param zoom The new zoom level\n   */\n  setView(center, zoom) {\n    if (null != this.map && null != center && null != zoom) {\n      this.map.setView(center, zoom, this.zoomPanOptions);\n    }\n  }\n  /**\n   * Set the map zoom level\n   * @param zoom the new zoom level for the map\n   */\n  setZoom(zoom) {\n    if (null != this.map && null != zoom) {\n      this.map.setZoom(zoom, this.zoomOptions);\n    }\n  }\n  /**\n   * Set the center of the map\n   * @param center the center point\n   */\n  setCenter(center) {\n    if (null != this.map && null != center) {\n      this.map.panTo(center, this.panOptions);\n    }\n  }\n  /**\n   * Fit the map to the bounds\n   * @param latLngBounds the boundary to set\n   */\n  setFitBounds(latLngBounds) {\n    if (null != this.map && null != latLngBounds) {\n      this.map.fitBounds(latLngBounds, this.fitBoundsOptions);\n    }\n  }\n  /**\n   * Set the map's max bounds\n   * @param latLngBounds the boundary to set\n   */\n  setMaxBounds(latLngBounds) {\n    if (null != this.map && null != latLngBounds) {\n      this.map.setMaxBounds(latLngBounds);\n    }\n  }\n  /**\n   * Set the map's min zoom\n   * @param number the new min zoom\n   */\n  setMinZoom(zoom) {\n    if (null != this.map && null != zoom) {\n      this.map.setMinZoom(zoom);\n    }\n  }\n  /**\n   * Set the map's min zoom\n   * @param number the new min zoom\n   */\n  setMaxZoom(zoom) {\n    if (null != this.map && null != zoom) {\n      this.map.setMaxZoom(zoom);\n    }\n  }\n  static #_ = this.ɵfac = function LeafletDirective_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || LeafletDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  static #_2 = this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: LeafletDirective,\n    selectors: [[\"\", \"leaflet\", \"\"]],\n    hostBindings: function LeafletDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"resize\", function LeafletDirective_resize_HostBindingHandler() {\n          return ctx.onResize();\n        }, false, i0.ɵɵresolveWindow);\n      }\n    },\n    inputs: {\n      fitBoundsOptions: [0, \"leafletFitBoundsOptions\", \"fitBoundsOptions\"],\n      panOptions: [0, \"leafletPanOptions\", \"panOptions\"],\n      zoomOptions: [0, \"leafletZoomOptions\", \"zoomOptions\"],\n      zoomPanOptions: [0, \"leafletZoomPanOptions\", \"zoomPanOptions\"],\n      options: [0, \"leafletOptions\", \"options\"],\n      zoom: [0, \"leafletZoom\", \"zoom\"],\n      center: [0, \"leafletCenter\", \"center\"],\n      fitBounds: [0, \"leafletFitBounds\", \"fitBounds\"],\n      maxBounds: [0, \"leafletMaxBounds\", \"maxBounds\"],\n      minZoom: [0, \"leafletMinZoom\", \"minZoom\"],\n      maxZoom: [0, \"leafletMaxZoom\", \"maxZoom\"]\n    },\n    outputs: {\n      mapReady: \"leafletMapReady\",\n      zoomChange: \"leafletZoomChange\",\n      centerChange: \"leafletCenterChange\",\n      onClick: \"leafletClick\",\n      onDoubleClick: \"leafletDoubleClick\",\n      onMouseDown: \"leafletMouseDown\",\n      onMouseUp: \"leafletMouseUp\",\n      onMouseMove: \"leafletMouseMove\",\n      onMouseOver: \"leafletMouseOver\",\n      onMouseOut: \"leafletMouseOut\",\n      onMapMove: \"leafletMapMove\",\n      onMapMoveStart: \"leafletMapMoveStart\",\n      onMapMoveEnd: \"leafletMapMoveEnd\",\n      onMapZoom: \"leafletMapZoom\",\n      onMapZoomStart: \"leafletMapZoomStart\",\n      onMapZoomEnd: \"leafletMapZoomEnd\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(LeafletDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[leaflet]'\n    }]\n  }], () => [{\n    type: i0.ElementRef\n  }, {\n    type: i0.NgZone\n  }], {\n    fitBoundsOptions: [{\n      type: Input,\n      args: ['leafletFitBoundsOptions']\n    }],\n    panOptions: [{\n      type: Input,\n      args: ['leafletPanOptions']\n    }],\n    zoomOptions: [{\n      type: Input,\n      args: ['leafletZoomOptions']\n    }],\n    zoomPanOptions: [{\n      type: Input,\n      args: ['leafletZoomPanOptions']\n    }],\n    options: [{\n      type: Input,\n      args: ['leafletOptions']\n    }],\n    mapReady: [{\n      type: Output,\n      args: ['leafletMapReady']\n    }],\n    zoom: [{\n      type: Input,\n      args: ['leafletZoom']\n    }],\n    zoomChange: [{\n      type: Output,\n      args: ['leafletZoomChange']\n    }],\n    center: [{\n      type: Input,\n      args: ['leafletCenter']\n    }],\n    centerChange: [{\n      type: Output,\n      args: ['leafletCenterChange']\n    }],\n    fitBounds: [{\n      type: Input,\n      args: ['leafletFitBounds']\n    }],\n    maxBounds: [{\n      type: Input,\n      args: ['leafletMaxBounds']\n    }],\n    minZoom: [{\n      type: Input,\n      args: ['leafletMinZoom']\n    }],\n    maxZoom: [{\n      type: Input,\n      args: ['leafletMaxZoom']\n    }],\n    onClick: [{\n      type: Output,\n      args: ['leafletClick']\n    }],\n    onDoubleClick: [{\n      type: Output,\n      args: ['leafletDoubleClick']\n    }],\n    onMouseDown: [{\n      type: Output,\n      args: ['leafletMouseDown']\n    }],\n    onMouseUp: [{\n      type: Output,\n      args: ['leafletMouseUp']\n    }],\n    onMouseMove: [{\n      type: Output,\n      args: ['leafletMouseMove']\n    }],\n    onMouseOver: [{\n      type: Output,\n      args: ['leafletMouseOver']\n    }],\n    onMouseOut: [{\n      type: Output,\n      args: ['leafletMouseOut']\n    }],\n    onMapMove: [{\n      type: Output,\n      args: ['leafletMapMove']\n    }],\n    onMapMoveStart: [{\n      type: Output,\n      args: ['leafletMapMoveStart']\n    }],\n    onMapMoveEnd: [{\n      type: Output,\n      args: ['leafletMapMoveEnd']\n    }],\n    onMapZoom: [{\n      type: Output,\n      args: ['leafletMapZoom']\n    }],\n    onMapZoomStart: [{\n      type: Output,\n      args: ['leafletMapZoomStart']\n    }],\n    onMapZoomEnd: [{\n      type: Output,\n      args: ['leafletMapZoomEnd']\n    }],\n    onResize: [{\n      type: HostListener,\n      args: ['window:resize', []]\n    }]\n  });\n})();\nclass LeafletDirectiveWrapper {\n  constructor(leafletDirective) {\n    this.leafletDirective = leafletDirective;\n  }\n  init() {\n    // Nothing for now\n  }\n  getMap() {\n    return this.leafletDirective.getMap();\n  }\n}\n\n/**\n * Layer directive\n *\n * This directive is used to directly control a single map layer. The purpose of this directive is to\n * be used as part of a child structural directive of the map element.\n *\n */\nclass LeafletLayerDirective {\n  constructor(leafletDirective, zone) {\n    this.zone = zone;\n    // Layer Events\n    this.onAdd = new EventEmitter();\n    this.onRemove = new EventEmitter();\n    this.leafletDirective = new LeafletDirectiveWrapper(leafletDirective);\n  }\n  ngOnInit() {\n    // Init the map\n    this.leafletDirective.init();\n  }\n  ngOnDestroy() {\n    if (null != this.layer) {\n      // Unregister the event handlers\n      this.removeLayerEventListeners(this.layer);\n      // Remove the layer from the map\n      this.layer.remove();\n    }\n  }\n  ngOnChanges(changes) {\n    if (changes['layer']) {\n      // Update the layer\n      const p = changes['layer'].previousValue;\n      const n = changes['layer'].currentValue;\n      this.zone.runOutsideAngular(() => {\n        if (null != p) {\n          this.removeLayerEventListeners(p);\n          p.remove();\n        }\n        if (null != n) {\n          this.addLayerEventListeners(n);\n          this.leafletDirective.getMap().addLayer(n);\n        }\n      });\n    }\n  }\n  addLayerEventListeners(l) {\n    this.onAddLayerHandler = e => LeafletUtil.handleEvent(this.zone, this.onAdd, e);\n    l.on('add', this.onAddLayerHandler);\n    this.onRemoveLayerHandler = e => LeafletUtil.handleEvent(this.zone, this.onRemove, e);\n    l.on('remove', this.onRemoveLayerHandler);\n  }\n  removeLayerEventListeners(l) {\n    l.off('add', this.onAddLayerHandler);\n    l.off('remove', this.onRemoveLayerHandler);\n  }\n  static #_ = this.ɵfac = function LeafletLayerDirective_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || LeafletLayerDirective)(i0.ɵɵdirectiveInject(LeafletDirective), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  static #_2 = this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: LeafletLayerDirective,\n    selectors: [[\"\", \"leafletLayer\", \"\"]],\n    inputs: {\n      layer: [0, \"leafletLayer\", \"layer\"]\n    },\n    outputs: {\n      onAdd: \"leafletLayerAdd\",\n      onRemove: \"leafletLayerRemove\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(LeafletLayerDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[leafletLayer]'\n    }]\n  }], () => [{\n    type: LeafletDirective\n  }, {\n    type: i0.NgZone\n  }], {\n    layer: [{\n      type: Input,\n      args: ['leafletLayer']\n    }],\n    onAdd: [{\n      type: Output,\n      args: ['leafletLayerAdd']\n    }],\n    onRemove: [{\n      type: Output,\n      args: ['leafletLayerRemove']\n    }]\n  });\n})();\n\n/**\n * Layers directive\n *\n * This directive is used to directly control map layers. As changes are made to the input array of\n * layers, the map is synched to the array. As layers are added or removed from the input array, they\n * are also added or removed from the map. The input array is treated as immutable. To detect changes,\n * you must change the array instance.\n *\n * Important Note: The input layers array is assumed to be immutable. This means you need to use an\n * immutable array implementation or create a new copy of your array when you make changes, otherwise\n * this directive won't detect the change. This is by design. It's for performance reasons. Change\n * detection of mutable arrays requires diffing the state of the array on every DoCheck cycle, which\n * is extremely expensive from a time complexity perspective.\n *\n */\nclass LeafletLayersDirective {\n  // Set/get the layers\n  set layers(v) {\n    this.layersValue = v;\n    // Now that we have a differ, do an immediate layer update\n    this.updateLayers();\n  }\n  get layers() {\n    return this.layersValue;\n  }\n  constructor(leafletDirective, differs, zone) {\n    this.differs = differs;\n    this.zone = zone;\n    this.leafletDirective = new LeafletDirectiveWrapper(leafletDirective);\n    this.layersDiffer = this.differs.find([]).create();\n  }\n  ngDoCheck() {\n    this.updateLayers();\n  }\n  ngOnInit() {\n    // Init the map\n    this.leafletDirective.init();\n    // Update layers once the map is ready\n    this.updateLayers();\n  }\n  ngOnDestroy() {\n    this.layers = [];\n  }\n  /**\n   * Update the state of the layers.\n   * We use an iterable differ to synchronize the map layers with the state of the bound layers array.\n   * This is important because it allows us to react to changes to the contents of the array as well\n   * as changes to the actual array instance.\n   */\n  updateLayers() {\n    const map = this.leafletDirective.getMap();\n    if (null != map && null != this.layersDiffer) {\n      const changes = this.layersDiffer.diff(this.layersValue);\n      if (null != changes) {\n        // Run outside angular to ensure layer events don't trigger change detection\n        this.zone.runOutsideAngular(() => {\n          changes.forEachRemovedItem(c => {\n            map.removeLayer(c.item);\n          });\n          changes.forEachAddedItem(c => {\n            map.addLayer(c.item);\n          });\n        });\n      }\n    }\n  }\n  static #_ = this.ɵfac = function LeafletLayersDirective_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || LeafletLayersDirective)(i0.ɵɵdirectiveInject(LeafletDirective), i0.ɵɵdirectiveInject(i0.IterableDiffers), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  static #_2 = this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: LeafletLayersDirective,\n    selectors: [[\"\", \"leafletLayers\", \"\"]],\n    inputs: {\n      layers: [0, \"leafletLayers\", \"layers\"]\n    }\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(LeafletLayersDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[leafletLayers]'\n    }]\n  }], () => [{\n    type: LeafletDirective\n  }, {\n    type: i0.IterableDiffers\n  }, {\n    type: i0.NgZone\n  }], {\n    layers: [{\n      type: Input,\n      args: ['leafletLayers']\n    }]\n  });\n})();\nclass LeafletControlLayersChanges {\n  constructor() {\n    this.layersRemoved = 0;\n    this.layersChanged = 0;\n    this.layersAdded = 0;\n  }\n  changed() {\n    return !(this.layersRemoved === 0 && this.layersChanged === 0 && this.layersAdded === 0);\n  }\n}\nclass LeafletControlLayersWrapper {\n  constructor(zone, layersControlReady) {\n    this.zone = zone;\n    this.layersControlReady = layersControlReady;\n  }\n  getLayersControl() {\n    return this.layersControl;\n  }\n  init(controlConfig, controlOptions) {\n    const baseLayers = controlConfig.baseLayers || {};\n    const overlays = controlConfig.overlays || {};\n    // Create the control outside of angular to ensure events don't trigger change detection\n    this.zone.runOutsideAngular(() => {\n      this.layersControl = control.layers(baseLayers, overlays, controlOptions);\n    });\n    this.layersControlReady.emit(this.layersControl);\n    return this.layersControl;\n  }\n  applyBaseLayerChanges(changes) {\n    let results = new LeafletControlLayersChanges();\n    if (null != this.layersControl) {\n      results = this.applyChanges(changes, this.layersControl.addBaseLayer);\n    }\n    return results;\n  }\n  applyOverlayChanges(changes) {\n    let results = new LeafletControlLayersChanges();\n    if (null != this.layersControl) {\n      results = this.applyChanges(changes, this.layersControl.addOverlay);\n    }\n    return results;\n  }\n  applyChanges(changes, addFn) {\n    const results = new LeafletControlLayersChanges();\n    if (null != changes) {\n      // All layer management is outside angular to avoid layer events from triggering change detection\n      this.zone.runOutsideAngular(() => {\n        changes.forEachChangedItem(c => {\n          this.layersControl.removeLayer(c.previousValue);\n          addFn.call(this.layersControl, c.currentValue, c.key);\n          results.layersChanged++;\n        });\n        changes.forEachRemovedItem(c => {\n          this.layersControl.removeLayer(c.previousValue);\n          results.layersRemoved++;\n        });\n        changes.forEachAddedItem(c => {\n          addFn.call(this.layersControl, c.currentValue, c.key);\n          results.layersAdded++;\n        });\n      });\n    }\n    return results;\n  }\n}\nclass LeafletControlLayersConfig {\n  constructor() {\n    this.baseLayers = {};\n    this.overlays = {};\n  }\n}\n\n/**\n * Layers Control\n *\n * This directive is used to configure the layers control. The input accepts an object with two\n * key-value maps of layer name -> layer. Mutable changes are detected. On changes, a differ is\n * used to determine what changed so that layers are appropriately added or removed.\n *\n * To specify which layer to show as the 'active' baselayer, you will want to add it to the map\n * using the layers directive. Otherwise, the last one it sees will be used.\n */\nclass LeafletLayersControlDirective {\n  set layersControlConfig(v) {\n    // Validation/init stuff\n    if (null == v) {\n      v = new LeafletControlLayersConfig();\n    }\n    if (null == v.baseLayers) {\n      v.baseLayers = {};\n    }\n    if (null == v.overlays) {\n      v.overlays = {};\n    }\n    // Store the value\n    this.layersControlConfigValue = v;\n    // Update the map\n    this.updateLayers();\n  }\n  get layersControlConfig() {\n    return this.layersControlConfigValue;\n  }\n  constructor(leafletDirective, differs, zone) {\n    this.differs = differs;\n    this.zone = zone;\n    this.layersControlReady = new EventEmitter();\n    this.leafletDirective = new LeafletDirectiveWrapper(leafletDirective);\n    this.controlLayers = new LeafletControlLayersWrapper(this.zone, this.layersControlReady);\n    // Generate differs\n    this.baseLayersDiffer = this.differs.find({}).create();\n    this.overlaysDiffer = this.differs.find({}).create();\n  }\n  ngOnInit() {\n    // Init the map\n    this.leafletDirective.init();\n    // Set up control outside of angular to avoid change detection when using the control\n    this.zone.runOutsideAngular(() => {\n      // Set up all the initial settings\n      this.controlLayers.init({}, this.layersControlOptions).addTo(this.leafletDirective.getMap());\n    });\n    this.updateLayers();\n  }\n  ngOnDestroy() {\n    this.layersControlConfig = {\n      baseLayers: {},\n      overlays: {}\n    };\n    this.controlLayers.getLayersControl().remove();\n  }\n  ngDoCheck() {\n    this.updateLayers();\n  }\n  updateLayers() {\n    const map = this.leafletDirective.getMap();\n    const layersControl = this.controlLayers.getLayersControl();\n    if (null != map && null != layersControl) {\n      // Run the baselayers differ\n      if (null != this.baseLayersDiffer && null != this.layersControlConfigValue.baseLayers) {\n        const changes = this.baseLayersDiffer.diff(this.layersControlConfigValue.baseLayers);\n        this.controlLayers.applyBaseLayerChanges(changes);\n      }\n      // Run the overlays differ\n      if (null != this.overlaysDiffer && null != this.layersControlConfigValue.overlays) {\n        const changes = this.overlaysDiffer.diff(this.layersControlConfigValue.overlays);\n        this.controlLayers.applyOverlayChanges(changes);\n      }\n    }\n  }\n  static #_ = this.ɵfac = function LeafletLayersControlDirective_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || LeafletLayersControlDirective)(i0.ɵɵdirectiveInject(LeafletDirective), i0.ɵɵdirectiveInject(i0.KeyValueDiffers), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  static #_2 = this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: LeafletLayersControlDirective,\n    selectors: [[\"\", \"leafletLayersControl\", \"\"]],\n    inputs: {\n      layersControlConfig: [0, \"leafletLayersControl\", \"layersControlConfig\"],\n      layersControlOptions: [0, \"leafletLayersControlOptions\", \"layersControlOptions\"]\n    },\n    outputs: {\n      layersControlReady: \"leafletLayersControlReady\"\n    }\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(LeafletLayersControlDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[leafletLayersControl]'\n    }]\n  }], () => [{\n    type: LeafletDirective\n  }, {\n    type: i0.KeyValueDiffers\n  }, {\n    type: i0.NgZone\n  }], {\n    layersControlConfig: [{\n      type: Input,\n      args: ['leafletLayersControl']\n    }],\n    layersControlOptions: [{\n      type: Input,\n      args: ['leafletLayersControlOptions']\n    }],\n    layersControlReady: [{\n      type: Output,\n      args: ['leafletLayersControlReady']\n    }]\n  });\n})();\n\n/**\n * Baselayers directive\n *\n * This directive is provided as a convenient way to add baselayers to the map. The input accepts\n * a key-value map of layer name -> layer. Mutable changed are detected. On changes, a differ is\n * used to determine what changed so that layers are appropriately added or removed. This directive\n * will also add the layers control so users can switch between available base layers.\n *\n * To specify which layer to show as the 'active' baselayer, you will want to add it to the map\n * using the layers directive. Otherwise, the plugin will use the last one it sees.\n */\nclass LeafletBaseLayersDirective {\n  // Set/get baseLayers\n  set baseLayers(v) {\n    this.baseLayersValue = v;\n    this.updateBaseLayers();\n  }\n  get baseLayers() {\n    return this.baseLayersValue;\n  }\n  constructor(leafletDirective, differs, zone) {\n    this.differs = differs;\n    this.zone = zone;\n    // Output for once the layers control is ready\n    this.layersControlReady = new EventEmitter();\n    this.leafletDirective = new LeafletDirectiveWrapper(leafletDirective);\n    this.controlLayers = new LeafletControlLayersWrapper(this.zone, this.layersControlReady);\n    this.baseLayersDiffer = this.differs.find({}).create();\n  }\n  ngOnDestroy() {\n    this.baseLayers = {};\n    if (null != this.controlLayers.getLayersControl()) {\n      this.controlLayers.getLayersControl().remove();\n    }\n  }\n  ngOnInit() {\n    // Init the map\n    this.leafletDirective.init();\n    // Create the control outside angular to prevent events from triggering chnage detection\n    this.zone.runOutsideAngular(() => {\n      // Initially configure the controlLayers\n      this.controlLayers.init({}, this.layersControlOptions).addTo(this.leafletDirective.getMap());\n    });\n    this.updateBaseLayers();\n  }\n  ngDoCheck() {\n    this.updateBaseLayers();\n  }\n  updateBaseLayers() {\n    const map = this.leafletDirective.getMap();\n    const layersControl = this.controlLayers.getLayersControl();\n    if (null != map && null != layersControl && null != this.baseLayersDiffer) {\n      const changes = this.baseLayersDiffer.diff(this.baseLayersValue);\n      const results = this.controlLayers.applyBaseLayerChanges(changes);\n      if (results.changed()) {\n        this.syncBaseLayer();\n      }\n    }\n  }\n  /**\n   * Check the current base layer and change it to the new one if necessary\n   */\n  syncBaseLayer() {\n    const map = this.leafletDirective.getMap();\n    const layers = LeafletUtil.mapToArray(this.baseLayers);\n    let foundLayer;\n    // Search all the layers in the map to see if we can find them in the baselayer array\n    map.eachLayer(l => {\n      foundLayer = layers.find(bl => l === bl);\n    });\n    // Did we find the layer?\n    if (null != foundLayer) {\n      // Yes - set the baselayer to the one we found\n      this.baseLayer = foundLayer;\n    } else {\n      // No - set the baselayer to the first in the array and add it to the map\n      if (layers.length > 0) {\n        this.baseLayer = layers[0];\n        // Add layers outside of angular to prevent events from triggering change detection\n        this.zone.runOutsideAngular(() => {\n          this.baseLayer.addTo(map);\n        });\n      }\n    }\n  }\n  static #_ = this.ɵfac = function LeafletBaseLayersDirective_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || LeafletBaseLayersDirective)(i0.ɵɵdirectiveInject(LeafletDirective), i0.ɵɵdirectiveInject(i0.KeyValueDiffers), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  static #_2 = this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: LeafletBaseLayersDirective,\n    selectors: [[\"\", \"leafletBaseLayers\", \"\"]],\n    inputs: {\n      baseLayers: [0, \"leafletBaseLayers\", \"baseLayers\"],\n      layersControlOptions: [0, \"leafletLayersControlOptions\", \"layersControlOptions\"]\n    },\n    outputs: {\n      layersControlReady: \"leafletLayersControlReady\"\n    }\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(LeafletBaseLayersDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[leafletBaseLayers]'\n    }]\n  }], () => [{\n    type: LeafletDirective\n  }, {\n    type: i0.KeyValueDiffers\n  }, {\n    type: i0.NgZone\n  }], {\n    baseLayers: [{\n      type: Input,\n      args: ['leafletBaseLayers']\n    }],\n    layersControlOptions: [{\n      type: Input,\n      args: ['leafletLayersControlOptions']\n    }],\n    layersControlReady: [{\n      type: Output,\n      args: ['leafletLayersControlReady']\n    }]\n  });\n})();\nclass LeafletModule {\n  static #_ = this.ɵfac = function LeafletModule_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || LeafletModule)();\n  };\n  static #_2 = this.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: LeafletModule\n  });\n  static #_3 = this.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(LeafletModule, [{\n    type: NgModule,\n    args: [{\n      exports: [LeafletDirective, LeafletLayerDirective, LeafletLayersDirective, LeafletLayersControlDirective, LeafletBaseLayersDirective],\n      declarations: [LeafletDirective, LeafletLayerDirective, LeafletLayersDirective, LeafletLayersControlDirective, LeafletBaseLayersDirective]\n    }]\n  }], null, null);\n})();\nclass LeafletTileLayerDefinition {\n  constructor(type, url, options) {\n    this.type = type;\n    this.url = url;\n    this.options = options;\n  }\n  /**\n   * Creates a TileLayer from the provided definition. This is a convenience function\n   * to help with generating layers from objects.\n   *\n   * @param layerDef The layer to create\n   * @returns {TileLayer} The TileLayer that has been created\n   */\n  static createTileLayer(layerDef) {\n    let layer;\n    switch (layerDef.type) {\n      case 'xyz':\n        layer = tileLayer(layerDef.url, layerDef.options);\n        break;\n      case 'wms':\n      default:\n        layer = tileLayer.wms(layerDef.url, layerDef.options);\n        break;\n    }\n    return layer;\n  }\n  /**\n   * Creates a TileLayer for each key in the incoming map. This is a convenience function\n   * for generating an associative array of layers from an associative array of objects\n   *\n   * @param layerDefs A map of key to tile layer definition\n   * @returns {{[p: string]: TileLayer}} A new map of key to TileLayer\n   */\n  static createTileLayers(layerDefs) {\n    const layers = {};\n    for (const k in layerDefs) {\n      if (layerDefs.hasOwnProperty(k)) {\n        layers[k] = LeafletTileLayerDefinition.createTileLayer(layerDefs[k]);\n      }\n    }\n    return layers;\n  }\n  /**\n   * Create a Tile Layer from the current state of this object\n   *\n   * @returns {TileLayer} A new TileLayer\n   */\n  createTileLayer() {\n    return LeafletTileLayerDefinition.createTileLayer(this);\n  }\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { LeafletBaseLayersDirective, LeafletControlLayersChanges, LeafletControlLayersConfig, LeafletControlLayersWrapper, LeafletDirective, LeafletDirectiveWrapper, LeafletLayerDirective, LeafletLayersControlDirective, LeafletLayersDirective, LeafletModule, LeafletTileLayerDefinition, LeafletUtil };","map":{"version":3,"names":["i0","EventEmitter","Directive","Input","Output","HostListener","NgModule","latLng","map","control","tileLayer","LeafletUtil","mapToArray","toReturn","k","hasOwnProperty","push","handleEvent","zone","eventEmitter","event","observers","length","run","emit","LeafletDirective","constructor","element","DEFAULT_ZOOM","DEFAULT_CENTER","DEFAULT_FPZ_OPTIONS","fitBoundsOptions","panOptions","zoomOptions","zoomPanOptions","options","mapReady","zoomChange","centerChange","onClick","onDoubleClick","onMouseDown","onMouseUp","onMouseMove","onMouseOver","onMouseOut","onMapMove","onMapMoveStart","onMapMoveEnd","onMapZoom","onMapZoomStart","onMapZoomEnd","ngOnInit","runOutsideAngular","nativeElement","addMapEventListeners","center","zoom","setView","fitBounds","setFitBounds","maxBounds","setMaxBounds","minZoom","setMinZoom","maxZoom","setMaxZoom","doResize","ngOnChanges","changes","currentValue","setZoom","setCenter","ngOnDestroy","remove","getMap","onResize","delayResize","registerEventHandler","eventName","handler","on","e","outputUpdateHandler","getZoom","getCenter","lat","lng","invalidateSize","resizeTimer","clearTimeout","setTimeout","bind","panTo","latLngBounds","_","ɵfac","LeafletDirective_Factory","__ngFactoryType__","ɵɵdirectiveInject","ElementRef","NgZone","_2","ɵdir","ɵɵdefineDirective","type","selectors","hostBindings","LeafletDirective_HostBindings","rf","ctx","ɵɵlistener","LeafletDirective_resize_HostBindingHandler","ɵɵresolveWindow","inputs","outputs","features","ɵɵNgOnChangesFeature","ngDevMode","ɵsetClassMetadata","args","selector","LeafletDirectiveWrapper","leafletDirective","init","LeafletLayerDirective","onAdd","onRemove","layer","removeLayerEventListeners","p","previousValue","n","addLayerEventListeners","addLayer","l","onAddLayerHandler","onRemoveLayerHandler","off","LeafletLayerDirective_Factory","LeafletLayersDirective","layers","v","layersValue","updateLayers","differs","layersDiffer","find","create","ngDoCheck","diff","forEachRemovedItem","c","removeLayer","item","forEachAddedItem","LeafletLayersDirective_Factory","IterableDiffers","LeafletControlLayersChanges","layersRemoved","layersChanged","layersAdded","changed","LeafletControlLayersWrapper","layersControlReady","getLayersControl","layersControl","controlConfig","controlOptions","baseLayers","overlays","applyBaseLayerChanges","results","applyChanges","addBaseLayer","applyOverlayChanges","addOverlay","addFn","forEachChangedItem","call","key","LeafletControlLayersConfig","LeafletLayersControlDirective","layersControlConfig","layersControlConfigValue","controlLayers","baseLayersDiffer","overlaysDiffer","layersControlOptions","addTo","LeafletLayersControlDirective_Factory","KeyValueDiffers","LeafletBaseLayersDirective","baseLayersValue","updateBaseLayers","syncBaseLayer","foundLayer","eachLayer","bl","baseLayer","LeafletBaseLayersDirective_Factory","LeafletModule","LeafletModule_Factory","ɵmod","ɵɵdefineNgModule","_3","ɵinj","ɵɵdefineInjector","exports","declarations","LeafletTileLayerDefinition","url","createTileLayer","layerDef","wms","createTileLayers","layerDefs"],"sources":["/Users/gentritibishi/IdeaProjects/WQM_IOT/node_modules/@asymmetrik/ngx-leaflet/fesm2022/asymmetrik-ngx-leaflet.mjs"],"sourcesContent":["import * as i0 from '@angular/core';\nimport { EventEmitter, Directive, Input, Output, HostListener, NgModule } from '@angular/core';\nimport { latLng, map, control, tileLayer } from 'leaflet';\n\nclass LeafletUtil {\n    static mapToArray(map) {\n        const toReturn = [];\n        for (const k in map) {\n            if (map.hasOwnProperty(k)) {\n                toReturn.push(map[k]);\n            }\n        }\n        return toReturn;\n    }\n    static handleEvent(zone, eventEmitter, event) {\n        // Don't want to emit if there are no observers\n        if (0 < eventEmitter.observers.length) {\n            zone.run(() => {\n                eventEmitter.emit(event);\n            });\n        }\n    }\n}\n\nclass LeafletDirective {\n    constructor(element, zone) {\n        this.element = element;\n        this.zone = zone;\n        this.DEFAULT_ZOOM = 1;\n        this.DEFAULT_CENTER = latLng(38.907192, -77.036871);\n        this.DEFAULT_FPZ_OPTIONS = {};\n        this.fitBoundsOptions = this.DEFAULT_FPZ_OPTIONS;\n        this.panOptions = this.DEFAULT_FPZ_OPTIONS;\n        this.zoomOptions = this.DEFAULT_FPZ_OPTIONS;\n        this.zoomPanOptions = this.DEFAULT_FPZ_OPTIONS;\n        // Default configuration\n        this.options = {};\n        // Configure callback function for the map\n        this.mapReady = new EventEmitter();\n        this.zoomChange = new EventEmitter();\n        this.centerChange = new EventEmitter();\n        // Mouse Map Events\n        this.onClick = new EventEmitter();\n        this.onDoubleClick = new EventEmitter();\n        this.onMouseDown = new EventEmitter();\n        this.onMouseUp = new EventEmitter();\n        this.onMouseMove = new EventEmitter();\n        this.onMouseOver = new EventEmitter();\n        this.onMouseOut = new EventEmitter();\n        // Map Move Events\n        this.onMapMove = new EventEmitter();\n        this.onMapMoveStart = new EventEmitter();\n        this.onMapMoveEnd = new EventEmitter();\n        // Map Zoom Events\n        this.onMapZoom = new EventEmitter();\n        this.onMapZoomStart = new EventEmitter();\n        this.onMapZoomEnd = new EventEmitter();\n        // Nothing here\n    }\n    ngOnInit() {\n        // Create the map outside of angular so the various map events don't trigger change detection\n        this.zone.runOutsideAngular(() => {\n            // Create the map with some reasonable defaults\n            this.map = map(this.element.nativeElement, this.options);\n            this.addMapEventListeners();\n        });\n        // Only setView if there is a center/zoom\n        if (null != this.center && null != this.zoom) {\n            this.setView(this.center, this.zoom);\n        }\n        // Set up all the initial settings\n        if (null != this.fitBounds) {\n            this.setFitBounds(this.fitBounds);\n        }\n        if (null != this.maxBounds) {\n            this.setMaxBounds(this.maxBounds);\n        }\n        if (null != this.minZoom) {\n            this.setMinZoom(this.minZoom);\n        }\n        if (null != this.maxZoom) {\n            this.setMaxZoom(this.maxZoom);\n        }\n        this.doResize();\n        // Fire map ready event\n        this.mapReady.emit(this.map);\n    }\n    ngOnChanges(changes) {\n        /*\n         * The following code is to address an issue with our (basic) implementation of\n         * zooming and panning. From our testing, it seems that a pan operation followed\n         * by a zoom operation in the same thread will interfere with eachother. The zoom\n         * operation interrupts/cancels the pan, resulting in a final center point that is\n         * inaccurate. The solution seems to be to either separate them with a timeout or\n          * to collapse them into a setView call.\n         */\n        // Zooming and Panning\n        if (changes['zoom'] && changes['center'] && null != this.zoom && null != this.center) {\n            this.setView(changes['center'].currentValue, changes['zoom'].currentValue);\n        }\n        // Set the zoom level\n        else if (changes['zoom']) {\n            this.setZoom(changes['zoom'].currentValue);\n        }\n        // Set the map center\n        else if (changes['center']) {\n            this.setCenter(changes['center'].currentValue);\n        }\n        // Other options\n        if (changes['fitBounds']) {\n            this.setFitBounds(changes['fitBounds'].currentValue);\n        }\n        if (changes['maxBounds']) {\n            this.setMaxBounds(changes['maxBounds'].currentValue);\n        }\n        if (changes['minZoom']) {\n            this.setMinZoom(changes['minZoom'].currentValue);\n        }\n        if (changes['maxZoom']) {\n            this.setMaxZoom(changes['maxZoom'].currentValue);\n        }\n    }\n    ngOnDestroy() {\n        // If this directive is destroyed, the map is too\n        if (null != this.map) {\n            this.map.remove();\n        }\n    }\n    getMap() {\n        return this.map;\n    }\n    onResize() {\n        this.delayResize();\n    }\n    addMapEventListeners() {\n        const registerEventHandler = (eventName, handler) => {\n            this.map.on(eventName, handler);\n        };\n        // Add all the pass-through mouse event handlers\n        registerEventHandler('click', (e) => LeafletUtil.handleEvent(this.zone, this.onClick, e));\n        registerEventHandler('dblclick', (e) => LeafletUtil.handleEvent(this.zone, this.onDoubleClick, e));\n        registerEventHandler('mousedown', (e) => LeafletUtil.handleEvent(this.zone, this.onMouseDown, e));\n        registerEventHandler('mouseup', (e) => LeafletUtil.handleEvent(this.zone, this.onMouseUp, e));\n        registerEventHandler('mouseover', (e) => LeafletUtil.handleEvent(this.zone, this.onMouseOver, e));\n        registerEventHandler('mouseout', (e) => LeafletUtil.handleEvent(this.zone, this.onMouseOut, e));\n        registerEventHandler('mousemove', (e) => LeafletUtil.handleEvent(this.zone, this.onMouseMove, e));\n        registerEventHandler('zoomstart', (e) => LeafletUtil.handleEvent(this.zone, this.onMapZoomStart, e));\n        registerEventHandler('zoom', (e) => LeafletUtil.handleEvent(this.zone, this.onMapZoom, e));\n        registerEventHandler('zoomend', (e) => LeafletUtil.handleEvent(this.zone, this.onMapZoomEnd, e));\n        registerEventHandler('movestart', (e) => LeafletUtil.handleEvent(this.zone, this.onMapMoveStart, e));\n        registerEventHandler('move', (e) => LeafletUtil.handleEvent(this.zone, this.onMapMove, e));\n        registerEventHandler('moveend', (e) => LeafletUtil.handleEvent(this.zone, this.onMapMoveEnd, e));\n        // Update any things for which we provide output bindings\n        const outputUpdateHandler = () => {\n            const zoom = this.map.getZoom();\n            if (zoom !== this.zoom) {\n                this.zoom = zoom;\n                LeafletUtil.handleEvent(this.zone, this.zoomChange, zoom);\n            }\n            const center = this.map.getCenter();\n            if (null != center || null != this.center) {\n                if (((null == center || null == this.center) && center !== this.center)\n                    || (center.lat !== this.center.lat || center.lng !== this.center.lng)) {\n                    this.center = center;\n                    LeafletUtil.handleEvent(this.zone, this.centerChange, center);\n                }\n            }\n        };\n        registerEventHandler('moveend', outputUpdateHandler);\n        registerEventHandler('zoomend', outputUpdateHandler);\n    }\n    /**\n     * Resize the map to fit it's parent container\n     */\n    doResize() {\n        // Run this outside of angular so the map events stay outside of angular\n        this.zone.runOutsideAngular(() => {\n            // Invalidate the map size to trigger it to update itself\n            if (null != this.map) {\n                this.map.invalidateSize({});\n            }\n        });\n    }\n    /**\n     * Manage a delayed resize of the component\n     */\n    delayResize() {\n        if (null != this.resizeTimer) {\n            clearTimeout(this.resizeTimer);\n        }\n        this.resizeTimer = setTimeout(this.doResize.bind(this), 200);\n    }\n    /**\n     * Set the view (center/zoom) all at once\n     * @param center The new center\n     * @param zoom The new zoom level\n     */\n    setView(center, zoom) {\n        if (null != this.map && null != center && null != zoom) {\n            this.map.setView(center, zoom, this.zoomPanOptions);\n        }\n    }\n    /**\n     * Set the map zoom level\n     * @param zoom the new zoom level for the map\n     */\n    setZoom(zoom) {\n        if (null != this.map && null != zoom) {\n            this.map.setZoom(zoom, this.zoomOptions);\n        }\n    }\n    /**\n     * Set the center of the map\n     * @param center the center point\n     */\n    setCenter(center) {\n        if (null != this.map && null != center) {\n            this.map.panTo(center, this.panOptions);\n        }\n    }\n    /**\n     * Fit the map to the bounds\n     * @param latLngBounds the boundary to set\n     */\n    setFitBounds(latLngBounds) {\n        if (null != this.map && null != latLngBounds) {\n            this.map.fitBounds(latLngBounds, this.fitBoundsOptions);\n        }\n    }\n    /**\n     * Set the map's max bounds\n     * @param latLngBounds the boundary to set\n     */\n    setMaxBounds(latLngBounds) {\n        if (null != this.map && null != latLngBounds) {\n            this.map.setMaxBounds(latLngBounds);\n        }\n    }\n    /**\n     * Set the map's min zoom\n     * @param number the new min zoom\n     */\n    setMinZoom(zoom) {\n        if (null != this.map && null != zoom) {\n            this.map.setMinZoom(zoom);\n        }\n    }\n    /**\n     * Set the map's min zoom\n     * @param number the new min zoom\n     */\n    setMaxZoom(zoom) {\n        if (null != this.map && null != zoom) {\n            this.map.setMaxZoom(zoom);\n        }\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"18.0.1\", ngImport: i0, type: LeafletDirective, deps: [{ token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Directive }); }\n    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"18.0.1\", type: LeafletDirective, selector: \"[leaflet]\", inputs: { fitBoundsOptions: [\"leafletFitBoundsOptions\", \"fitBoundsOptions\"], panOptions: [\"leafletPanOptions\", \"panOptions\"], zoomOptions: [\"leafletZoomOptions\", \"zoomOptions\"], zoomPanOptions: [\"leafletZoomPanOptions\", \"zoomPanOptions\"], options: [\"leafletOptions\", \"options\"], zoom: [\"leafletZoom\", \"zoom\"], center: [\"leafletCenter\", \"center\"], fitBounds: [\"leafletFitBounds\", \"fitBounds\"], maxBounds: [\"leafletMaxBounds\", \"maxBounds\"], minZoom: [\"leafletMinZoom\", \"minZoom\"], maxZoom: [\"leafletMaxZoom\", \"maxZoom\"] }, outputs: { mapReady: \"leafletMapReady\", zoomChange: \"leafletZoomChange\", centerChange: \"leafletCenterChange\", onClick: \"leafletClick\", onDoubleClick: \"leafletDoubleClick\", onMouseDown: \"leafletMouseDown\", onMouseUp: \"leafletMouseUp\", onMouseMove: \"leafletMouseMove\", onMouseOver: \"leafletMouseOver\", onMouseOut: \"leafletMouseOut\", onMapMove: \"leafletMapMove\", onMapMoveStart: \"leafletMapMoveStart\", onMapMoveEnd: \"leafletMapMoveEnd\", onMapZoom: \"leafletMapZoom\", onMapZoomStart: \"leafletMapZoomStart\", onMapZoomEnd: \"leafletMapZoomEnd\" }, host: { listeners: { \"window:resize\": \"onResize()\" } }, usesOnChanges: true, ngImport: i0 }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"18.0.1\", ngImport: i0, type: LeafletDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[leaflet]'\n                }]\n        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: i0.NgZone }], propDecorators: { fitBoundsOptions: [{\n                type: Input,\n                args: ['leafletFitBoundsOptions']\n            }], panOptions: [{\n                type: Input,\n                args: ['leafletPanOptions']\n            }], zoomOptions: [{\n                type: Input,\n                args: ['leafletZoomOptions']\n            }], zoomPanOptions: [{\n                type: Input,\n                args: ['leafletZoomPanOptions']\n            }], options: [{\n                type: Input,\n                args: ['leafletOptions']\n            }], mapReady: [{\n                type: Output,\n                args: ['leafletMapReady']\n            }], zoom: [{\n                type: Input,\n                args: ['leafletZoom']\n            }], zoomChange: [{\n                type: Output,\n                args: ['leafletZoomChange']\n            }], center: [{\n                type: Input,\n                args: ['leafletCenter']\n            }], centerChange: [{\n                type: Output,\n                args: ['leafletCenterChange']\n            }], fitBounds: [{\n                type: Input,\n                args: ['leafletFitBounds']\n            }], maxBounds: [{\n                type: Input,\n                args: ['leafletMaxBounds']\n            }], minZoom: [{\n                type: Input,\n                args: ['leafletMinZoom']\n            }], maxZoom: [{\n                type: Input,\n                args: ['leafletMaxZoom']\n            }], onClick: [{\n                type: Output,\n                args: ['leafletClick']\n            }], onDoubleClick: [{\n                type: Output,\n                args: ['leafletDoubleClick']\n            }], onMouseDown: [{\n                type: Output,\n                args: ['leafletMouseDown']\n            }], onMouseUp: [{\n                type: Output,\n                args: ['leafletMouseUp']\n            }], onMouseMove: [{\n                type: Output,\n                args: ['leafletMouseMove']\n            }], onMouseOver: [{\n                type: Output,\n                args: ['leafletMouseOver']\n            }], onMouseOut: [{\n                type: Output,\n                args: ['leafletMouseOut']\n            }], onMapMove: [{\n                type: Output,\n                args: ['leafletMapMove']\n            }], onMapMoveStart: [{\n                type: Output,\n                args: ['leafletMapMoveStart']\n            }], onMapMoveEnd: [{\n                type: Output,\n                args: ['leafletMapMoveEnd']\n            }], onMapZoom: [{\n                type: Output,\n                args: ['leafletMapZoom']\n            }], onMapZoomStart: [{\n                type: Output,\n                args: ['leafletMapZoomStart']\n            }], onMapZoomEnd: [{\n                type: Output,\n                args: ['leafletMapZoomEnd']\n            }], onResize: [{\n                type: HostListener,\n                args: ['window:resize', []]\n            }] } });\n\nclass LeafletDirectiveWrapper {\n    constructor(leafletDirective) {\n        this.leafletDirective = leafletDirective;\n    }\n    init() {\n        // Nothing for now\n    }\n    getMap() {\n        return this.leafletDirective.getMap();\n    }\n}\n\n/**\n * Layer directive\n *\n * This directive is used to directly control a single map layer. The purpose of this directive is to\n * be used as part of a child structural directive of the map element.\n *\n */\nclass LeafletLayerDirective {\n    constructor(leafletDirective, zone) {\n        this.zone = zone;\n        // Layer Events\n        this.onAdd = new EventEmitter();\n        this.onRemove = new EventEmitter();\n        this.leafletDirective = new LeafletDirectiveWrapper(leafletDirective);\n    }\n    ngOnInit() {\n        // Init the map\n        this.leafletDirective.init();\n    }\n    ngOnDestroy() {\n        if (null != this.layer) {\n            // Unregister the event handlers\n            this.removeLayerEventListeners(this.layer);\n            // Remove the layer from the map\n            this.layer.remove();\n        }\n    }\n    ngOnChanges(changes) {\n        if (changes['layer']) {\n            // Update the layer\n            const p = changes['layer'].previousValue;\n            const n = changes['layer'].currentValue;\n            this.zone.runOutsideAngular(() => {\n                if (null != p) {\n                    this.removeLayerEventListeners(p);\n                    p.remove();\n                }\n                if (null != n) {\n                    this.addLayerEventListeners(n);\n                    this.leafletDirective.getMap().addLayer(n);\n                }\n            });\n        }\n    }\n    addLayerEventListeners(l) {\n        this.onAddLayerHandler = (e) => LeafletUtil.handleEvent(this.zone, this.onAdd, e);\n        l.on('add', this.onAddLayerHandler);\n        this.onRemoveLayerHandler = (e) => LeafletUtil.handleEvent(this.zone, this.onRemove, e);\n        l.on('remove', this.onRemoveLayerHandler);\n    }\n    removeLayerEventListeners(l) {\n        l.off('add', this.onAddLayerHandler);\n        l.off('remove', this.onRemoveLayerHandler);\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"18.0.1\", ngImport: i0, type: LeafletLayerDirective, deps: [{ token: LeafletDirective }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Directive }); }\n    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"18.0.1\", type: LeafletLayerDirective, selector: \"[leafletLayer]\", inputs: { layer: [\"leafletLayer\", \"layer\"] }, outputs: { onAdd: \"leafletLayerAdd\", onRemove: \"leafletLayerRemove\" }, usesOnChanges: true, ngImport: i0 }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"18.0.1\", ngImport: i0, type: LeafletLayerDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[leafletLayer]'\n                }]\n        }], ctorParameters: () => [{ type: LeafletDirective }, { type: i0.NgZone }], propDecorators: { layer: [{\n                type: Input,\n                args: ['leafletLayer']\n            }], onAdd: [{\n                type: Output,\n                args: ['leafletLayerAdd']\n            }], onRemove: [{\n                type: Output,\n                args: ['leafletLayerRemove']\n            }] } });\n\n/**\n * Layers directive\n *\n * This directive is used to directly control map layers. As changes are made to the input array of\n * layers, the map is synched to the array. As layers are added or removed from the input array, they\n * are also added or removed from the map. The input array is treated as immutable. To detect changes,\n * you must change the array instance.\n *\n * Important Note: The input layers array is assumed to be immutable. This means you need to use an\n * immutable array implementation or create a new copy of your array when you make changes, otherwise\n * this directive won't detect the change. This is by design. It's for performance reasons. Change\n * detection of mutable arrays requires diffing the state of the array on every DoCheck cycle, which\n * is extremely expensive from a time complexity perspective.\n *\n */\nclass LeafletLayersDirective {\n    // Set/get the layers\n    set layers(v) {\n        this.layersValue = v;\n        // Now that we have a differ, do an immediate layer update\n        this.updateLayers();\n    }\n    get layers() {\n        return this.layersValue;\n    }\n    constructor(leafletDirective, differs, zone) {\n        this.differs = differs;\n        this.zone = zone;\n        this.leafletDirective = new LeafletDirectiveWrapper(leafletDirective);\n        this.layersDiffer = this.differs.find([]).create();\n    }\n    ngDoCheck() {\n        this.updateLayers();\n    }\n    ngOnInit() {\n        // Init the map\n        this.leafletDirective.init();\n        // Update layers once the map is ready\n        this.updateLayers();\n    }\n    ngOnDestroy() {\n        this.layers = [];\n    }\n    /**\n     * Update the state of the layers.\n     * We use an iterable differ to synchronize the map layers with the state of the bound layers array.\n     * This is important because it allows us to react to changes to the contents of the array as well\n     * as changes to the actual array instance.\n     */\n    updateLayers() {\n        const map = this.leafletDirective.getMap();\n        if (null != map && null != this.layersDiffer) {\n            const changes = this.layersDiffer.diff(this.layersValue);\n            if (null != changes) {\n                // Run outside angular to ensure layer events don't trigger change detection\n                this.zone.runOutsideAngular(() => {\n                    changes.forEachRemovedItem((c) => {\n                        map.removeLayer(c.item);\n                    });\n                    changes.forEachAddedItem((c) => {\n                        map.addLayer(c.item);\n                    });\n                });\n            }\n        }\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"18.0.1\", ngImport: i0, type: LeafletLayersDirective, deps: [{ token: LeafletDirective }, { token: i0.IterableDiffers }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Directive }); }\n    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"18.0.1\", type: LeafletLayersDirective, selector: \"[leafletLayers]\", inputs: { layers: [\"leafletLayers\", \"layers\"] }, ngImport: i0 }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"18.0.1\", ngImport: i0, type: LeafletLayersDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[leafletLayers]'\n                }]\n        }], ctorParameters: () => [{ type: LeafletDirective }, { type: i0.IterableDiffers }, { type: i0.NgZone }], propDecorators: { layers: [{\n                type: Input,\n                args: ['leafletLayers']\n            }] } });\n\nclass LeafletControlLayersChanges {\n    constructor() {\n        this.layersRemoved = 0;\n        this.layersChanged = 0;\n        this.layersAdded = 0;\n    }\n    changed() {\n        return !(this.layersRemoved === 0 && this.layersChanged === 0 && this.layersAdded === 0);\n    }\n}\n\nclass LeafletControlLayersWrapper {\n    constructor(zone, layersControlReady) {\n        this.zone = zone;\n        this.layersControlReady = layersControlReady;\n    }\n    getLayersControl() {\n        return this.layersControl;\n    }\n    init(controlConfig, controlOptions) {\n        const baseLayers = controlConfig.baseLayers || {};\n        const overlays = controlConfig.overlays || {};\n        // Create the control outside of angular to ensure events don't trigger change detection\n        this.zone.runOutsideAngular(() => {\n            this.layersControl = control.layers(baseLayers, overlays, controlOptions);\n        });\n        this.layersControlReady.emit(this.layersControl);\n        return this.layersControl;\n    }\n    applyBaseLayerChanges(changes) {\n        let results = new LeafletControlLayersChanges();\n        if (null != this.layersControl) {\n            results = this.applyChanges(changes, this.layersControl.addBaseLayer);\n        }\n        return results;\n    }\n    applyOverlayChanges(changes) {\n        let results = new LeafletControlLayersChanges();\n        if (null != this.layersControl) {\n            results = this.applyChanges(changes, this.layersControl.addOverlay);\n        }\n        return results;\n    }\n    applyChanges(changes, addFn) {\n        const results = new LeafletControlLayersChanges();\n        if (null != changes) {\n            // All layer management is outside angular to avoid layer events from triggering change detection\n            this.zone.runOutsideAngular(() => {\n                changes.forEachChangedItem((c) => {\n                    this.layersControl.removeLayer(c.previousValue);\n                    addFn.call(this.layersControl, c.currentValue, c.key);\n                    results.layersChanged++;\n                });\n                changes.forEachRemovedItem((c) => {\n                    this.layersControl.removeLayer(c.previousValue);\n                    results.layersRemoved++;\n                });\n                changes.forEachAddedItem((c) => {\n                    addFn.call(this.layersControl, c.currentValue, c.key);\n                    results.layersAdded++;\n                });\n            });\n        }\n        return results;\n    }\n}\n\nclass LeafletControlLayersConfig {\n    constructor() {\n        this.baseLayers = {};\n        this.overlays = {};\n    }\n}\n\n/**\n * Layers Control\n *\n * This directive is used to configure the layers control. The input accepts an object with two\n * key-value maps of layer name -> layer. Mutable changes are detected. On changes, a differ is\n * used to determine what changed so that layers are appropriately added or removed.\n *\n * To specify which layer to show as the 'active' baselayer, you will want to add it to the map\n * using the layers directive. Otherwise, the last one it sees will be used.\n */\nclass LeafletLayersControlDirective {\n    set layersControlConfig(v) {\n        // Validation/init stuff\n        if (null == v) {\n            v = new LeafletControlLayersConfig();\n        }\n        if (null == v.baseLayers) {\n            v.baseLayers = {};\n        }\n        if (null == v.overlays) {\n            v.overlays = {};\n        }\n        // Store the value\n        this.layersControlConfigValue = v;\n        // Update the map\n        this.updateLayers();\n    }\n    get layersControlConfig() {\n        return this.layersControlConfigValue;\n    }\n    constructor(leafletDirective, differs, zone) {\n        this.differs = differs;\n        this.zone = zone;\n        this.layersControlReady = new EventEmitter();\n        this.leafletDirective = new LeafletDirectiveWrapper(leafletDirective);\n        this.controlLayers = new LeafletControlLayersWrapper(this.zone, this.layersControlReady);\n        // Generate differs\n        this.baseLayersDiffer = this.differs.find({}).create();\n        this.overlaysDiffer = this.differs.find({}).create();\n    }\n    ngOnInit() {\n        // Init the map\n        this.leafletDirective.init();\n        // Set up control outside of angular to avoid change detection when using the control\n        this.zone.runOutsideAngular(() => {\n            // Set up all the initial settings\n            this.controlLayers\n                .init({}, this.layersControlOptions)\n                .addTo(this.leafletDirective.getMap());\n        });\n        this.updateLayers();\n    }\n    ngOnDestroy() {\n        this.layersControlConfig = { baseLayers: {}, overlays: {} };\n        this.controlLayers.getLayersControl().remove();\n    }\n    ngDoCheck() {\n        this.updateLayers();\n    }\n    updateLayers() {\n        const map = this.leafletDirective.getMap();\n        const layersControl = this.controlLayers.getLayersControl();\n        if (null != map && null != layersControl) {\n            // Run the baselayers differ\n            if (null != this.baseLayersDiffer && null != this.layersControlConfigValue.baseLayers) {\n                const changes = this.baseLayersDiffer.diff(this.layersControlConfigValue.baseLayers);\n                this.controlLayers.applyBaseLayerChanges(changes);\n            }\n            // Run the overlays differ\n            if (null != this.overlaysDiffer && null != this.layersControlConfigValue.overlays) {\n                const changes = this.overlaysDiffer.diff(this.layersControlConfigValue.overlays);\n                this.controlLayers.applyOverlayChanges(changes);\n            }\n        }\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"18.0.1\", ngImport: i0, type: LeafletLayersControlDirective, deps: [{ token: LeafletDirective }, { token: i0.KeyValueDiffers }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Directive }); }\n    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"18.0.1\", type: LeafletLayersControlDirective, selector: \"[leafletLayersControl]\", inputs: { layersControlConfig: [\"leafletLayersControl\", \"layersControlConfig\"], layersControlOptions: [\"leafletLayersControlOptions\", \"layersControlOptions\"] }, outputs: { layersControlReady: \"leafletLayersControlReady\" }, ngImport: i0 }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"18.0.1\", ngImport: i0, type: LeafletLayersControlDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[leafletLayersControl]'\n                }]\n        }], ctorParameters: () => [{ type: LeafletDirective }, { type: i0.KeyValueDiffers }, { type: i0.NgZone }], propDecorators: { layersControlConfig: [{\n                type: Input,\n                args: ['leafletLayersControl']\n            }], layersControlOptions: [{\n                type: Input,\n                args: ['leafletLayersControlOptions']\n            }], layersControlReady: [{\n                type: Output,\n                args: ['leafletLayersControlReady']\n            }] } });\n\n/**\n * Baselayers directive\n *\n * This directive is provided as a convenient way to add baselayers to the map. The input accepts\n * a key-value map of layer name -> layer. Mutable changed are detected. On changes, a differ is\n * used to determine what changed so that layers are appropriately added or removed. This directive\n * will also add the layers control so users can switch between available base layers.\n *\n * To specify which layer to show as the 'active' baselayer, you will want to add it to the map\n * using the layers directive. Otherwise, the plugin will use the last one it sees.\n */\nclass LeafletBaseLayersDirective {\n    // Set/get baseLayers\n    set baseLayers(v) {\n        this.baseLayersValue = v;\n        this.updateBaseLayers();\n    }\n    get baseLayers() {\n        return this.baseLayersValue;\n    }\n    constructor(leafletDirective, differs, zone) {\n        this.differs = differs;\n        this.zone = zone;\n        // Output for once the layers control is ready\n        this.layersControlReady = new EventEmitter();\n        this.leafletDirective = new LeafletDirectiveWrapper(leafletDirective);\n        this.controlLayers = new LeafletControlLayersWrapper(this.zone, this.layersControlReady);\n        this.baseLayersDiffer = this.differs.find({}).create();\n    }\n    ngOnDestroy() {\n        this.baseLayers = {};\n        if (null != this.controlLayers.getLayersControl()) {\n            this.controlLayers.getLayersControl().remove();\n        }\n    }\n    ngOnInit() {\n        // Init the map\n        this.leafletDirective.init();\n        // Create the control outside angular to prevent events from triggering chnage detection\n        this.zone.runOutsideAngular(() => {\n            // Initially configure the controlLayers\n            this.controlLayers\n                .init({}, this.layersControlOptions)\n                .addTo(this.leafletDirective.getMap());\n        });\n        this.updateBaseLayers();\n    }\n    ngDoCheck() {\n        this.updateBaseLayers();\n    }\n    updateBaseLayers() {\n        const map = this.leafletDirective.getMap();\n        const layersControl = this.controlLayers.getLayersControl();\n        if (null != map && null != layersControl && null != this.baseLayersDiffer) {\n            const changes = this.baseLayersDiffer.diff(this.baseLayersValue);\n            const results = this.controlLayers.applyBaseLayerChanges(changes);\n            if (results.changed()) {\n                this.syncBaseLayer();\n            }\n        }\n    }\n    /**\n     * Check the current base layer and change it to the new one if necessary\n     */\n    syncBaseLayer() {\n        const map = this.leafletDirective.getMap();\n        const layers = LeafletUtil.mapToArray(this.baseLayers);\n        let foundLayer;\n        // Search all the layers in the map to see if we can find them in the baselayer array\n        map.eachLayer((l) => {\n            foundLayer = layers.find((bl) => (l === bl));\n        });\n        // Did we find the layer?\n        if (null != foundLayer) {\n            // Yes - set the baselayer to the one we found\n            this.baseLayer = foundLayer;\n        }\n        else {\n            // No - set the baselayer to the first in the array and add it to the map\n            if (layers.length > 0) {\n                this.baseLayer = layers[0];\n                // Add layers outside of angular to prevent events from triggering change detection\n                this.zone.runOutsideAngular(() => {\n                    this.baseLayer.addTo(map);\n                });\n            }\n        }\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"18.0.1\", ngImport: i0, type: LeafletBaseLayersDirective, deps: [{ token: LeafletDirective }, { token: i0.KeyValueDiffers }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Directive }); }\n    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"14.0.0\", version: \"18.0.1\", type: LeafletBaseLayersDirective, selector: \"[leafletBaseLayers]\", inputs: { baseLayers: [\"leafletBaseLayers\", \"baseLayers\"], layersControlOptions: [\"leafletLayersControlOptions\", \"layersControlOptions\"] }, outputs: { layersControlReady: \"leafletLayersControlReady\" }, ngImport: i0 }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"18.0.1\", ngImport: i0, type: LeafletBaseLayersDirective, decorators: [{\n            type: Directive,\n            args: [{\n                    selector: '[leafletBaseLayers]'\n                }]\n        }], ctorParameters: () => [{ type: LeafletDirective }, { type: i0.KeyValueDiffers }, { type: i0.NgZone }], propDecorators: { baseLayers: [{\n                type: Input,\n                args: ['leafletBaseLayers']\n            }], layersControlOptions: [{\n                type: Input,\n                args: ['leafletLayersControlOptions']\n            }], layersControlReady: [{\n                type: Output,\n                args: ['leafletLayersControlReady']\n            }] } });\n\nclass LeafletModule {\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"18.0.1\", ngImport: i0, type: LeafletModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }\n    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"18.0.1\", ngImport: i0, type: LeafletModule, declarations: [LeafletDirective,\n            LeafletLayerDirective,\n            LeafletLayersDirective,\n            LeafletLayersControlDirective,\n            LeafletBaseLayersDirective], exports: [LeafletDirective,\n            LeafletLayerDirective,\n            LeafletLayersDirective,\n            LeafletLayersControlDirective,\n            LeafletBaseLayersDirective] }); }\n    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"18.0.1\", ngImport: i0, type: LeafletModule }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"18.0.1\", ngImport: i0, type: LeafletModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    exports: [\n                        LeafletDirective,\n                        LeafletLayerDirective,\n                        LeafletLayersDirective,\n                        LeafletLayersControlDirective,\n                        LeafletBaseLayersDirective\n                    ],\n                    declarations: [\n                        LeafletDirective,\n                        LeafletLayerDirective,\n                        LeafletLayersDirective,\n                        LeafletLayersControlDirective,\n                        LeafletBaseLayersDirective\n                    ]\n                }]\n        }] });\n\nclass LeafletTileLayerDefinition {\n    constructor(type, url, options) {\n        this.type = type;\n        this.url = url;\n        this.options = options;\n    }\n    /**\n     * Creates a TileLayer from the provided definition. This is a convenience function\n     * to help with generating layers from objects.\n     *\n     * @param layerDef The layer to create\n     * @returns {TileLayer} The TileLayer that has been created\n     */\n    static createTileLayer(layerDef) {\n        let layer;\n        switch (layerDef.type) {\n            case 'xyz':\n                layer = tileLayer(layerDef.url, layerDef.options);\n                break;\n            case 'wms':\n            default:\n                layer = tileLayer.wms(layerDef.url, layerDef.options);\n                break;\n        }\n        return layer;\n    }\n    /**\n     * Creates a TileLayer for each key in the incoming map. This is a convenience function\n     * for generating an associative array of layers from an associative array of objects\n     *\n     * @param layerDefs A map of key to tile layer definition\n     * @returns {{[p: string]: TileLayer}} A new map of key to TileLayer\n     */\n    static createTileLayers(layerDefs) {\n        const layers = {};\n        for (const k in layerDefs) {\n            if (layerDefs.hasOwnProperty(k)) {\n                layers[k] = (LeafletTileLayerDefinition.createTileLayer(layerDefs[k]));\n            }\n        }\n        return layers;\n    }\n    /**\n     * Create a Tile Layer from the current state of this object\n     *\n     * @returns {TileLayer} A new TileLayer\n     */\n    createTileLayer() {\n        return LeafletTileLayerDefinition.createTileLayer(this);\n    }\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { LeafletBaseLayersDirective, LeafletControlLayersChanges, LeafletControlLayersConfig, LeafletControlLayersWrapper, LeafletDirective, LeafletDirectiveWrapper, LeafletLayerDirective, LeafletLayersControlDirective, LeafletLayersDirective, LeafletModule, LeafletTileLayerDefinition, LeafletUtil };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}